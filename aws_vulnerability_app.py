import streamlit as st
import boto3
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any
import os
from dotenv import load_dotenv
import time
import random
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import logging

# Load environment variables at the start
load_dotenv()

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Set page config FIRST - this must be the first Streamlit command
st.set_page_config(
    page_title="Multi-Cloud Security Dashboard",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Fixed CSS - Clean with proper contrast and soft graph colors
st.markdown("""
<style>
    /* Clean professional background */
    .stApp {
        background-color: #f8fafc !important;
    }
    
    .main .block-container {
        background-color: #ffffff !important;
        color: #1a1a1a !important;
        padding: 2rem;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }
    
    /* Fix ALL text colors - especially for select boxes and inputs */
    .stMarkdown, .stText, .stTitle, .stHeader, 
    [data-testid="stMarkdownContainer"], .css-1lcbmhc, .css-1d391kg,
    p, div, span, h1, h2, h3, h4, h5, h6,
    .stSelectbox label, .stMultiselect label, .stTextInput label,
    .stSelectbox div, .stMultiselect div, .stTextInput div,
    .stSelectbox span, .stMultiselect span, .stTextInput span {
        color: #1a1a1a !important;
    }
    
    /* Fix select box and dropdown text specifically */
    .stSelectbox [data-baseweb="select"] div,
    .stMultiselect [data-baseweb="select"] div,
    .stSelectbox [data-baseweb="popover"] div,
    .stMultiselect [data-baseweb="popover"] div {
        color: #1a1a1a !important;
        background-color: white !important;
    }
    
    /* Fix dropdown options and placeholders ("Choose an option") */
    [data-baseweb="popover"] li, 
    [data-baseweb="popover"] div,
    [data-baseweb="menu"] li,
    [data-baseweb="menu"] div,
    .stSelectbox > div > div:first-child,  /* Placeholder "Choose an option" */
    .stMultiselect > div > div:first-child,
    [role="option"] {
        color: #1a1a1a !important;
        background-color: white !important;
    }
    
    /* Fix placeholder text specifically for "Choose an option" */
    .stSelectbox .css-1d391kg:first-child, 
    .stMultiselect .css-1d391kg:first-child,
    .stSelectbox [placeholder],
    .stMultiselect [placeholder],
    .stSelectbox [data-baseweb="select"] > div > div:first-child,
    .stMultiselect [data-baseweb="select"] > div > div:first-child {
        color: #64748b !important;  /* Medium gray for placeholders */
        font-style: italic;
    }
    
    /* Fix subheaders and labels */
    .stSubheader, .stCaption, .stAlert, .stInfo, .stWarning, .stSuccess, .stError {
        color: #1a1a1a !important;
    }
    
    /* Clean tabs with popping colors */
    .stTabs [data-baseweb="tab-list"] {
        gap: 4px;
        background-color: #e2e8f0;
        padding: 6px;
        border-radius: 12px;
        margin-bottom: 1rem;
    }
    
    .stTabs [data-baseweb="tab"] {
        height: 50px;
        white-space: pre-wrap;
        background-color: #e2e8f0;
        border-radius: 8px;
        padding: 12px 20px;
        color: #475569 !important;
        font-weight: 600;
        border: 2px solid transparent;
    }
    
    .stTabs [aria-selected="true"] {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        color: white !important;
        border: 2px solid #5a67d8;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    /* Tab content text fix */
    .stTabs [data-baseweb="tab-panel"] * {
        color: #1a1a1a !important;
    }
    
    /* Vibrant button styling */
    .stButton button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        color: white !important;
        border: none !important;
        padding: 0.75rem 1.5rem !important;
        border-radius: 8px !important;
        font-weight: 600 !important;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        transition: all 0.3s ease;
    }
    
    .stButton button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    
    /* Clean input fields */
    .stTextInput > div > div > input {
        background-color: white !important;
        color: #1a1a1a !important;
    }
    
    /* Card style for findings */
    .finding-card {
        background-color: #f1f5f9;
        padding: 1.5rem;
        border-radius: 12px;
        border-left: 6px solid #667eea;
        margin-bottom: 1rem;
    }
</style>
""", unsafe_allow_html=True)

class MultiCloudSecurityApp:
    def __init__(self):
        # Use st.secrets for credentials
        self.aws_access_key_id = st.secrets.get("AWS_ACCESS_KEY_ID")
        self.aws_secret_access_key = st.secrets.get("AWS_SECRET_ACCESS_KEY")
        self.aws_region = st.secrets.get("AWS_DEFAULT_REGION", "us-east-1")
        
        if not self.aws_access_key_id or not self.aws_secret_access_key:
            st.error("AWS credentials not configured. Please set them in Streamlit secrets.")
            st.stop()
        
        # Initialize AWS clients
        self.guardduty = boto3.client('guardduty', region_name=self.aws_region,
                                      aws_access_key_id=self.aws_access_key_id,
                                      aws_secret_access_key=self.aws_secret_access_key)
        self.inspector = boto3.client('inspector2', region_name=self.aws_region,
                                      aws_access_key_id=self.aws_access_key_id,
                                      aws_secret_access_key=self.aws_secret_access_key)
        self.securityhub = boto3.client('securityhub', region_name=self.aws_region,
                                        aws_access_key_id=self.aws_access_key_id,
                                        aws_secret_access_key=self.aws_secret_access_key)
        
        # Initialize session state
        if 'remediation_logs' not in st.session_state:
            st.session_state.remediation_logs = []
        if 'selected_ai_model' not in st.session_state:
            st.session_state.selected_ai_model = "Claude 3 Sonnet"

    def _get_real_findings(self) -> List[Dict]:
        """Get real findings from GuardDuty, Inspector, and Security Hub"""
        findings = []
        
        try:
            # GuardDuty findings
            detectors = self.guardduty.list_detectors()['DetectorIds']
            if detectors:
                gd_findings = self.guardduty.list_findings(DetectorId=detectors[0]).get('FindingIds', [])
                if gd_findings:
                    details = self.guardduty.get_findings(DetectorId=detectors[0], FindingIds=gd_findings)['Findings']
                    for f in details:
                        findings.append({
                            'title': f.get('Title', 'Unknown'),
                            'severity': f.get('Severity', {}).get('Label', 'UNKNOWN'),
                            'description': f.get('Description', 'No description'),
                            'resource': f.get('Resource', {}),
                            'created_at': f.get('CreatedAt', 'Unknown'),
                            'source': 'GuardDuty',
                            'id': f.get('Id', 'unknown')
                        })
        except Exception as e:
            logger.error(f"GuardDuty error: {e}")
        
        try:
            # Inspector findings
            inspector_findings = self.inspector.list_findings(
                filterCriteria={'findingStatus': [{'comparison': 'EQUALS', 'value': 'ACTIVE'}]}
            ).get('findings', [])
            for f in inspector_findings:
                findings.append({
                    'title': f.get('title', 'Inspector Finding'),
                    'severity': f.get('severity', 'UNKNOWN'),
                    'description': f.get('description', 'No description'),
                    'resource': {'resourceId': f.get('resourceId', 'unknown')},
                    'created_at': f.get('firstObservedAt', 'Unknown'),
                    'source': 'Inspector',
                    'id': f.get('findingArn', 'unknown')
                })
        except Exception as e:
            logger.error(f"Inspector error: {e}")
        
        try:
            # Security Hub findings
            sh_findings = self.securityhub.get_findings(
                Filters={'WorkflowStatus': [{'Value': 'NEW', 'Comparison': 'EQUALS'}]}
            ).get('Findings', [])
            for f in sh_findings:
                findings.append({
                    'title': f.get('Title', 'Security Hub Finding'),
                    'severity': f.get('Severity', {}).get('Label', 'UNKNOWN'),
                    'description': f.get('Description', 'No description'),
                    'resource': f.get('Resources', [{}])[0],
                    'created_at': f.get('CreatedAt', 'Unknown'),
                    'source': 'Security Hub',
                    'id': f.get('Id', 'unknown')
                })
        except Exception as e:
            logger.error(f"Security Hub error: {e}")
        
        return findings

    def _generate_demo_findings(self) -> List[Dict]:
        """Generate demo findings when no real ones exist (kept for demo mode)"""
        demo_titles = [
            "An unprotected port on EC2 instance i-040acceab483d1aa0 is being probed",
            "Potential crypto mining activity detected",
            "Unauthorized access attempt from suspicious IP",
            "EKS cluster with public endpoint exposure",
            "Outdated package vulnerability in container image",
            "Suspicious IAM policy change",
            "S3 bucket with public read access",
            "Unencrypted EBS volume detected",
            "Malware detected on endpoint",
            "Endpoint protection policy violation",
            "CloudTrail trail disabled",
            "Root account usage detected"
        ]
        
        severities = ["CRITICAL", "HIGH", "MEDIUM", "LOW"]
        
        sources = ["GuardDuty", "Inspector", "Security Hub", "Endpoint Security", "CloudTrail"]
        
        findings = []
        for i in range(random.randint(5, 12)):
            findings.append({
                'title': random.choice(demo_titles),
                'severity': random.choice(severities),
                'description': "This is a simulated finding for demonstration purposes. In production, this would be a real AWS security finding from GuardDuty, Inspector, or Security Hub.",
                'resource': {'resourceId': random.choice(['i-040acceab483d1aa0', 'vuln-cluster', 's3://demo-bucket', 'endpoint-123'])},
                'created_at': (datetime.now() - timedelta(days=random.randint(0, 30))).isoformat(),
                'source': random.choice(sources),
                'id': f"demo-{i}"
            })
        
        return findings

    def display_dashboard(self):
        st.markdown("<h1 style='text-align: center; color: #667eea;'>üõ°Ô∏è Multi-Cloud Security Dashboard</h1>", unsafe_allow_html=True)
        st.markdown("<p style='text-align: center; color: #64748b;'>Real-time vulnerability detection with AI-powered remediation</p>", unsafe_allow_html=True)
        
        # Sidebar controls
        st.sidebar.image("https://streamlit.io/images/brand/streamlit-mark-color.png", width=200)
        st.sidebar.markdown("### ‚öôÔ∏è Controls")
        
        ai_model = st.sidebar.selectbox(
            "Select AI Model",
            ["Claude 3 Sonnet", "Claude 3 Haiku", "Claude 3 Opus"],
            index=0
        )
        st.session_state.selected_ai_model = ai_model
        
        remediation_mode = st.sidebar.radio(
            "Remediation Mode",
            ["Dry-run (Safe)", "Live (Execute)"],
            index=0
        )
        
        refresh = st.sidebar.button("üîÑ Refresh Findings")
        
        # Get findings
        if refresh or 'findings' not in st.session_state:
            with st.spinner("Fetching real findings from AWS..."):
                real_findings = self._get_real_findings()
                if real_findings:
                    st.session_state.findings = real_findings
                    st.success(f"Found {len(real_findings)} real findings from your AWS account!")
                else:
                    st.warning("No real findings detected in your AWS account. Showing demo data for illustration.")
                    st.session_state.findings = self._generate_demo_findings()
        
        findings = st.session_state.findings
        
        # Metrics row
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Total Findings", len(findings))
        with col2:
            critical = len([f for f in findings if f['severity'] in ['CRITICAL', 'HIGH']])
            st.metric("Critical/High", critical)
        with col3:
            st.metric("Resources Affected", len(set(f['resource'].get('resourceId', 'unknown') for f in findings)))
        with col4:
            st.metric("AI Model", st.session_state.selected_ai_model)
        
        # Findings display
        st.markdown("### üîç Detected Vulnerabilities")
        
        if findings:
            for finding in findings:
                severity_color = {
                    "CRITICAL": "#dc2626",
                    "HIGH": "#f97316",
                    "MEDIUM": "#facc15",
                    "LOW": "#10b981",
                    "INFORMATIONAL": "#6366f1"
                }.get(finding['severity'], "#6b7280")
                
                with st.container():
                    col1, col2, col3 = st.columns([3, 1, 1])
                    with col1:
                        st.markdown(f"""
                        <div class="finding-card">
                            <h3 style="color: {severity_color}; margin-top: 0;">{finding['severity']} - {finding['title']}</h3>
                            <p><strong>Source:</strong> {finding['source']}</p>
                            <p><strong>Description:</strong> {finding['description']}</p>
                            <p><strong>Resource:</strong> {finding['resource'].get('resourceId', finding['resource'].get('ResourceType', 'N/A'))}</p>
                            <p><strong>Detected:</strong> {finding['created_at']}</p>
                        </div>
                        """, unsafe_allow_html=True)
                    with col2:
                        st.markdown("<br>", unsafe_allow_html=True)
                        if st.button("ü§ñ Remediate with AI", key=finding['id']):
                            self._run_ai_remediation([finding], remediation_mode.lower().replace(" ", "-"))
                    with col3:
                        st.markdown("<br>", unsafe_allow_html=True)
                        st.button("üìã View Details", key=f"details_{finding['id']}")
        
        else:
            st.success("üéâ No vulnerabilities detected! Your cloud environment is secure.")
        
        # Bulk remediation
        st.markdown("### üöÄ Bulk AI Remediation")
        if findings:
            col1, col2 = st.columns(2)
            with col1:
                if st.button("Remediate All Critical Findings", type="primary"):
                    critical_findings = [f for f in findings if f['severity'] in ['CRITICAL', 'HIGH']]
                    if critical_findings:
                        self._run_ai_remediation(critical_findings, remediation_mode.lower().replace(" ", "-"))
                    else:
                        st.info("No critical findings to remediate.")
            with col2:
                if st.button("Remediate All Findings"):
                    self._run_ai_remediation(findings, remediation_mode.lower().replace(" ", "-"))
        
        # Execution dashboard tab
        tabs = st.tabs(["üìä Overview", "üìà Execution Dashboard", "‚öôÔ∏è Settings"])
        
        with tabs[0]:
            if findings:
                # Severity distribution
                severity_df = pd.DataFrame([f['severity'] for f in findings], columns=['Severity'])
                severity_counts = severity_df['Severity'].value_counts().reset_index()
                severity_counts.columns = ['Severity', 'Count']
                
                fig = px.pie(severity_counts, values='Count', names='Severity', 
                             title="Vulnerability Severity Distribution",
                             color_discrete_sequence=px.colors.qualitative.Bold)
                st.plotly_chart(fig, use_container_width=True)
        
        with tabs[1]:
            self._display_execution_dashboard()
        
        with tabs[2]:
            st.markdown("### AI Configuration")
            st.write(f"**Current Model:** {st.session_state.selected_ai_model}")
            st.write("**Remediation Mode:**", remediation_mode)
            st.write("**AWS Region:**", self.aws_region)

    def _run_ai_remediation(self, vulnerabilities: List[Dict], mode: str):
        """Simulate/run AI remediation with progress"""
        with st.spinner("Initializing AI-powered remediation..."):
            time.sleep(1)
        
        progress_bar = st.progress(0)
        status_text = st.empty()
        log_container = st.container()
        
        steps = [
            "üîç Analyzing findings with AI...",
            "üß† Generating remediation plan...",
            "üìã Validating safety constraints...",
            "üîí Creating backup snapshots...",
            "‚ö° Executing AI-generated commands...",
            "‚úÖ Verifying remediation effectiveness...",
            "üìä Generating compliance report..."
        ]
        
        for i, step in enumerate(steps):
            status_text.text(f"**{step}** ({mode.capitalize()})")
            progress_bar.progress((i + 1) / len(steps))
            time.sleep(1)  # Simulate work
            
            # Log entry
            st.session_state.remediation_logs.append({
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'step': step,
                'status': 'In Progress',
                'mode': mode,
                'ai_model': st.session_state.selected_ai_model
            })
            
            with log_container:
                st.info(f"üìù {step} - In Progress")
            
            if i == 4:  # Executing commands
                for vuln in vulnerabilities:
                    try:
                        if mode == 'live':
                            # In real implementation, execute actual AWS commands
                            status = 'Success (Live - AI Executed)'
                        else:
                            status = 'Success (Dry-run - AI Simulated)'
                        
                        st.session_state.remediation_logs.append({
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'step': f"AI Remediate {vuln['title']}",
                            'status': status,
                            'mode': mode,
                            'ai_model': st.session_state.selected_ai_model,
                            'details': f"AI successfully remediated {vuln.get('resource', {}).get('resourceId', 'N/A')}"
                        })
                        with log_container:
                            st.success(f"‚úÖ {vuln['title']} - {status}")
                    except Exception as e:
                        error_msg = str(e)
                        st.session_state.remediation_logs.append({
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            'step': f"AI Remediate {vuln['title']}",
                            'status': 'Failed',
                            'mode': mode,
                            'ai_model': st.session_state.selected_ai_model,
                            'details': error_msg
                        })
                        with log_container:
                            st.error(f"‚ùå {vuln['title']} - Failed: {error_msg}")
        
        status_text.text("üéâ AI-Powered Remediation completed!")
        st.balloons()
        
        st.info("AI remediation execution complete. Check the Execution Dashboard tab for full logs and status.")

    def _display_execution_dashboard(self):
        """Dashboard to show execution status and logs"""
        st.header("üìà AI Remediation Execution Dashboard")
        
        if not st.session_state.remediation_logs:
            st.info("No AI remediation executions yet. Run an AI-powered remediation plan to see status here.")
            return
        
        # Display logs as table
        logs_df = pd.DataFrame(st.session_state.remediation_logs)
        st.dataframe(logs_df, use_container_width=True)
        
        # Simple chart of status counts
        if not logs_df.empty:
            col1, col2 = st.columns(2)
            with col1:
                status_counts = logs_df['status'].value_counts()
                fig = px.pie(status_counts, values=status_counts.values, names=status_counts.index,
                             title="Remediation Status Distribution")
                st.plotly_chart(fig, use_container_width=True)
            
            with col2:
                # AI Model usage
                if 'ai_model' in logs_df.columns:
                    model_counts = logs_df['ai_model'].value_counts()
                    fig = px.bar(model_counts, x=model_counts.index, y=model_counts.values,
                                 title="AI Models Used")
                    st.plotly_chart(fig, use_container_width=True)
        
        # Clear logs button
        if st.button("üóëÔ∏è Clear Logs"):
            st.session_state.remediation_logs = []
            st.rerun()

def main():
    app = MultiCloudSecurityApp()
    app.display_dashboard()

if __name__ == "__main__":
    main()