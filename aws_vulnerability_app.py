import streamlit as st
import boto3
import json
from datetime import datetime
from typing import Dict, List, Any
import os
from dotenv import load_dotenv

# Load environment variables at the start
load_dotenv()

# Set page config FIRST - this must be the first Streamlit command
st.set_page_config(
    page_title="AWS Vulnerability Remediation AI",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS - after page config
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #FF4B4B;
        text-align: center;
        margin-bottom: 2rem;
    }
    .severity-critical { background-color: #FF0000; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-high { background-color: #FF4B4B; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-medium { background-color: #FFA500; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-low { background-color: #008000; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-info { background-color: #0066CC; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    
    .resource-card { 
        border-left: 5px solid #FF4B4B; 
        padding: 15px; 
        margin: 10px 0; 
        background-color: #f0f2f6;
        border-radius: 5px;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        margin: 5px;
        border: 1px solid #ddd;
    }
    .service-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        margin: 10px;
    }
    .vulnerability-item {
        border-left: 4px solid;
        padding: 10px;
        margin: 5px 0;
        background-color: #f8f9fa;
        border-radius: 5px;
    }
    .success-box { background-color: #d4edda; border-left: 5px solid #28a745; padding: 15px; border-radius: 5px; }
    .warning-box { background-color: #fff3cd; border-left: 5px solid #ffc107; padding: 15px; border-radius: 5px; }
    .error-box { background-color: #f8d7da; border-left: 5px solid #dc3545; padding: 15px; border-radius: 5px; }
    .info-box { background-color: #d1ecf1; border-left: 5px solid #17a2b8; padding: 15px; border-radius: 5px; }
    
    .tab-content {
        padding: 20px;
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 10px 0;
    }
    
    .resource-details {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border-left: 4px solid #007bff;
    }
</style>
""", unsafe_allow_html=True)

class AWSVulnerabilityApp:
    def __init__(self):
        # Initialize session state variables
        if 'scan_results' not in st.session_state:
            st.session_state.scan_results = None
        if 'selected_vulnerabilities' not in st.session_state:
            st.session_state.selected_vulnerabilities = []
        if 'remediation_results' not in st.session_state:
            st.session_state.remediation_results = {}
        if 'ai_analysis_cache' not in st.session_state:
            st.session_state.ai_analysis_cache = {}
        if 'remediation_plan' not in st.session_state:
            st.session_state.remediation_plan = None
        if 'selected_services' not in st.session_state:
            st.session_state.selected_services = ['EC2', 'EKS', 'Lambda']
        if 'scan_details' not in st.session_state:
            st.session_state.scan_details = {}
            
        self.aws_clients = self._setup_aws_clients()
    
    def _setup_aws_clients(self):
        """Setup AWS clients - returns None if credentials not available"""
        try:
            # Check if credentials are available
            access_key = os.getenv('AWS_ACCESS_KEY_ID')
            secret_key = os.getenv('AWS_SECRET_ACCESS_KEY')
            region = os.getenv('AWS_REGION', 'us-east-1')
            
            if not access_key or not secret_key:
                st.warning("‚ö†Ô∏è AWS credentials not found in .env file. Using demo mode.")
                return None
            
            session = boto3.Session(
                aws_access_key_id=access_key,
                aws_secret_access_key=secret_key,
                region_name=region
            )
            
            clients = {
                'ec2': session.client('ec2'),
                'eks': session.client('eks'), 
                'lambda': session.client('lambda'),
                'securityhub': session.client('securityhub'),
                'inspector2': session.client('inspector2'),
                'iam': session.client('iam'),
                'cloudtrail': session.client('cloudtrail'),
            }
            
            # Try to setup Bedrock (might not be available in all regions)
            try:
                clients['bedrock-runtime'] = session.client('bedrock-runtime', region_name=region)
                st.success("‚úÖ AWS Bedrock configured successfully!")
            except Exception as e:
                st.info(f"‚ÑπÔ∏è Bedrock not available: {e}. Using simulated AI analysis.")
                clients['bedrock-runtime'] = None
                
            st.success(f"‚úÖ AWS clients configured for region: {region}")
            return clients
            
        except Exception as e:
            st.error(f"‚ùå AWS setup failed: {e}")
            return None

    def get_aws_regions(self):
        """Get available AWS regions"""
        try:
            ec2 = boto3.client('ec2', 
                             aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
                             aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'))
            regions = [region['RegionName'] for region in ec2.describe_regions()['Regions']]
            return regions
        except Exception as e:
            st.error(f"Failed to get regions: {e}")
            return ['us-east-1', 'us-west-2', 'eu-west-1']

    def run_comprehensive_scan(self, selected_services):
        """Run comprehensive AWS security scan with detailed resource discovery"""
        with st.spinner('üîç Performing comprehensive AWS security scan...'):
            try:
                scan_details = {}
                total_resources = 0
                
                # Progress tracking
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                if 'EC2' in selected_services:
                    status_text.text("üñ•Ô∏è Scanning EC2 Instances...")
                    ec2_resources = self._scan_ec2_detailed()
                    scan_details['EC2'] = ec2_resources
                    total_resources += len(ec2_resources)
                    progress_bar.progress(25)
                
                if 'EKS' in selected_services:
                    status_text.text("‚ò∏Ô∏è Scanning EKS Clusters...")
                    eks_resources = self._scan_eks_detailed()
                    scan_details['EKS'] = eks_resources
                    total_resources += len(eks_resources)
                    progress_bar.progress(50)
                
                if 'Lambda' in selected_services:
                    status_text.text("Œª Scanning Lambda Functions...")
                    lambda_resources = self._scan_lambda_detailed()
                    scan_details['Lambda'] = lambda_resources
                    total_resources += len(lambda_resources)
                    progress_bar.progress(75)
                
                if 'IAM' in selected_services:
                    status_text.text("üë§ Scanning IAM Resources...")
                    iam_findings = self._scan_iam_detailed()
                    scan_details['IAM'] = iam_findings
                    total_resources += len(iam_findings)
                    progress_bar.progress(90)
                
                # Combine all resources and vulnerabilities
                all_resources = []
                for service_resources in scan_details.values():
                    all_resources.extend(service_resources)
                
                vulnerabilities = self._extract_vulnerabilities(all_resources)
                
                st.session_state.scan_results = {
                    'resources': all_resources,
                    'vulnerabilities': vulnerabilities,
                    'scan_time': datetime.now().isoformat(),
                    'is_demo': not self.aws_clients,
                    'scan_details': scan_details,
                    'total_resources': total_resources
                }
                
                progress_bar.progress(100)
                status_text.text("‚úÖ Scan completed successfully!")
                
                st.success(f"üéØ Scan Complete: Found {total_resources} resources and {len(vulnerabilities)} vulnerabilities")
                
            except Exception as e:
                st.error(f"‚ùå Comprehensive scan failed: {e}")
                # Fallback to basic scan
                self.run_basic_scan()

    def _scan_ec2_detailed(self):
        """Detailed EC2 instance scanning"""
        resources = []
        try:
            ec2 = self.aws_clients['ec2']
            
            # Get all instances with detailed information
            paginator = ec2.get_paginator('describe_instances')
            for page in paginator.paginate():
                for reservation in page['Reservations']:
                    for instance in reservation['Instances']:
                        # Get detailed instance information
                        instance_details = {
                            'resource_id': instance['InstanceId'],
                            'resource_type': 'EC2',
                            'service': 'EC2',
                            'name': self._get_resource_name(instance.get('Tags', [])),
                            'state': instance['State']['Name'],
                            'instance_type': instance.get('InstanceType', 'N/A'),
                            'launch_time': instance['LaunchTime'].strftime('%Y-%m-%d %H:%M:%S'),
                            'vpc_id': instance.get('VpcId', 'N/A'),
                            'subnet_id': instance.get('SubnetId', 'N/A'),
                            'public_ip': instance.get('PublicIpAddress', 'Not Assigned'),
                            'private_ip': instance.get('PrivateIpAddress', 'N/A'),
                            'security_groups': [sg['GroupId'] for sg in instance.get('SecurityGroups', [])],
                            'key_name': instance.get('KeyName', 'N/A'),
                            'image_id': instance.get('ImageId', 'N/A'),
                            'availability_zone': instance.get('Placement', {}).get('AvailabilityZone', 'N/A'),
                            'vulnerabilities': self._check_ec2_vulnerabilities_detailed(instance)
                        }
                        resources.append(instance_details)
            
            st.info(f"üîç Found {len(resources)} EC2 instances")
            
        except Exception as e:
            st.error(f"EC2 scan error: {e}")
        
        return resources

    def _scan_eks_detailed(self):
        """Detailed EKS cluster scanning"""
        resources = []
        try:
            eks = self.aws_clients['eks']
            
            # List all EKS clusters
            clusters = eks.list_clusters()
            
            for cluster_name in clusters.get('clusters', []):
                # Get detailed cluster information
                cluster_info = eks.describe_cluster(name=cluster_name)
                cluster_data = cluster_info['cluster']
                
                cluster_details = {
                    'resource_id': cluster_data['name'],
                    'resource_type': 'EKS',
                    'service': 'EKS',
                    'name': cluster_data['name'],
                    'status': cluster_data['status'],
                    'version': cluster_data['version'],
                    'arn': cluster_data['arn'],
                    'endpoint': cluster_data.get('endpoint', 'N/A'),
                    'created_at': cluster_data.get('createdAt', 'N/A').strftime('%Y-%m-%d %H:%M:%S'),
                    'vpc_config': cluster_data.get('resourcesVpcConfig', {}),
                    'logging': cluster_data.get('logging', {}),
                    'vulnerabilities': self._check_eks_vulnerabilities_detailed(cluster_data)
                }
                resources.append(cluster_details)
            
            st.info(f"üîç Found {len(resources)} EKS clusters")
            
        except Exception as e:
            st.error(f"EKS scan error: {e}")
        
        return resources

    def _scan_lambda_detailed(self):
        """Detailed Lambda function scanning"""
        resources = []
        try:
            lambda_client = self.aws_clients['lambda']
            
            # Get all Lambda functions with pagination
            paginator = lambda_client.get_paginator('list_functions')
            for page in paginator.paginate():
                for function in page['Functions']:
                    function_details = {
                        'resource_id': function['FunctionName'],
                        'resource_type': 'Lambda',
                        'service': 'Lambda',
                        'name': function['FunctionName'],
                        'runtime': function.get('Runtime', 'N/A'),
                        'last_modified': function['LastModified'],
                        'memory_size': function.get('MemorySize', 'N/A'),
                        'timeout': function.get('Timeout', 'N/A'),
                        'arn': function['FunctionArn'],
                        'role': function.get('Role', 'N/A'),
                        'handler': function.get('Handler', 'N/A'),
                        'code_size': function.get('CodeSize', 0),
                        'environment_vars': list(function.get('Environment', {}).get('Variables', {}).keys()) if function.get('Environment') else [],
                        'vpc_config': function.get('VpcConfig', {}),
                        'vulnerabilities': self._check_lambda_vulnerabilities_detailed(function)
                    }
                    resources.append(function_details)
            
            st.info(f"üîç Found {len(resources)} Lambda functions")
            
        except Exception as e:
            st.error(f"Lambda scan error: {e}")
        
        return resources

    def _scan_iam_detailed(self):
        """Basic IAM security scanning"""
        findings = []
        try:
            iam = self.aws_clients['iam']
            
            # Check for root user access keys
            try:
                summary = iam.get_account_summary()
                if summary['SummaryMap']['AccountAccessKeysPresent'] == 1:
                    findings.append({
                        'resource_id': 'ROOT_USER',
                        'resource_type': 'IAM',
                        'service': 'IAM',
                        'name': 'Root User',
                        'vulnerabilities': [{
                            'id': 'IAM-ROOT-KEYS',
                            'title': 'Root Access Keys Exist',
                            'severity': 'CRITICAL',
                            'description': 'Root user access keys are present. This is a security risk.',
                            'remediation': 'Remove root access keys and use IAM users/roles',
                            'category': 'IAM Security'
                        }]
                    })
            except:
                pass
            
            st.info(f"üîç Found {len(findings)} IAM security findings")
            
        except Exception as e:
            st.error(f"IAM scan error: {e}")
        
        return findings

    def _check_ec2_vulnerabilities_detailed(self, instance):
        """Detailed EC2 vulnerability checks"""
        vulnerabilities = []
        
        # Public IP check
        if instance.get('PublicIpAddress'):
            vulnerabilities.append({
                'id': 'EC2-PUBLIC-IP',
                'title': 'EC2 Instance with Public IP',
                'severity': 'HIGH',
                'description': f"Instance {instance['InstanceId']} has public IP {instance['PublicIpAddress']} and is directly accessible from internet",
                'remediation': 'Move instance to private subnet or remove public IP',
                'category': 'Network Security',
                'resource_specific': {
                    'public_ip': instance['PublicIpAddress'],
                    'subnet_type': 'Public' if instance.get('PublicIpAddress') else 'Private'
                }
            })
        
        # IMDS configuration
        metadata_options = instance.get('MetadataOptions', {})
        if metadata_options.get('HttpTokens') != 'required':
            vulnerabilities.append({
                'id': 'EC2-IMDS-V1',
                'title': 'IMDSv1 Enabled',
                'severity': 'MEDIUM',
                'description': 'Instance Metadata Service v1 is enabled (less secure than v2)',
                'remediation': 'Enforce IMDSv2 only',
                'category': 'Instance Security'
            })
        
        # Security group checks
        for sg in instance.get('SecurityGroups', []):
            sg_vulns = self._check_security_group_detailed(sg['GroupId'])
            vulnerabilities.extend(sg_vulns)
        
        # EBS encryption check (simplified)
        for bdm in instance.get('BlockDeviceMappings', []):
            ebs = bdm.get('Ebs', {})
            if not ebs.get('Encrypted', False):
                vulnerabilities.append({
                    'id': 'EC2-EBS-UNENCRYPTED',
                    'title': 'Unencrypted EBS Volume',
                    'severity': 'MEDIUM',
                    'description': f"EBS volume {ebs.get('VolumeId', 'Unknown')} is not encrypted",
                    'remediation': 'Enable encryption for EBS volumes',
                    'category': 'Data Protection'
                })
                break
        
        return vulnerabilities

    def _check_security_group_detailed(self, sg_id):
        """Detailed security group vulnerability checks"""
        vulnerabilities = []
        try:
            ec2 = self.aws_clients['ec2']
            
            response = ec2.describe_security_group_rules(
                Filters=[{'Name': 'group-id', 'Values': [sg_id]}]
            )
            
            for rule in response['SecurityGroupRules']:
                if rule.get('IsEgress', False):
                    continue
                
                # Check for open CIDR
                if rule.get('CidrIpv4') == '0.0.0.0/0':
                    port_info = ""
                    if rule.get('FromPort') == rule.get('ToPort'):
                        port_info = f"port {rule.get('FromPort')}"
                    else:
                        port_info = f"ports {rule.get('FromPort')}-{rule.get('ToPort')}"
                    
                    severity = 'HIGH' if rule.get('FromPort') in [22, 3389, 1433, 3306] else 'MEDIUM'
                    
                    vulnerabilities.append({
                        'id': f'SG-OPEN-{rule.get("FromPort", "ANY")}',
                        'title': f'{rule["IpProtocol"].upper()} {port_info} Open To Internet',
                        'severity': severity,
                        'description': f'Security group {sg_id} allows {rule["IpProtocol"]} {port_info} from anywhere (0.0.0.0/0)',
                        'remediation': 'Restrict source IP range to specific networks',
                        'category': 'Network Security',
                        'resource_specific': {
                            'protocol': rule['IpProtocol'],
                            'port_range': f"{rule.get('FromPort', 'Any')}-{rule.get('ToPort', 'Any')}",
                            'source': '0.0.0.0/0'
                        }
                    })
        
        except Exception as e:
            st.error(f"Security group check error for {sg_id}: {e}")
        
        return vulnerabilities

    def _check_eks_vulnerabilities_detailed(self, cluster):
        """Detailed EKS vulnerability checks"""
        vulnerabilities = []
        
        # Check logging
        logging = cluster.get('logging', {}).get('clusterLogging', [{}])[0]
        if not logging.get('enabled', False):
            vulnerabilities.append({
                'id': 'EKS-LOGGING-DISABLED',
                'title': 'Control Plane Logging Disabled',
                'severity': 'MEDIUM',
                'description': 'EKS control plane logging is not enabled for audit purposes',
                'remediation': 'Enable control plane logging for all log types',
                'category': 'Logging & Monitoring'
            })
        
        # Check public endpoint
        vpc_config = cluster.get('resourcesVpcConfig', {})
        if vpc_config.get('endpointPublicAccess', False):
            if not vpc_config.get('endpointPrivateAccess', False):
                vulnerabilities.append({
                    'id': 'EKS-PUBLIC-ENDPOINT',
                    'title': 'Public Endpoint Without Private Access',
                    'severity': 'HIGH',
                    'description': 'EKS cluster API server is accessible from the internet without private access',
                    'remediation': 'Disable public endpoint or enable private access',
                    'category': 'Network Security'
                })
        
        # Check encryption
        if not cluster.get('encryptionConfig'):
            vulnerabilities.append({
                'id': 'EKS-NO-ENCRYPTION',
                'title': 'Secrets Not Encrypted with KMS',
                'severity': 'MEDIUM',
                'description': 'Kubernetes secrets are not encrypted with KMS keys',
                'remediation': 'Enable KMS encryption for Kubernetes secrets',
                'category': 'Data Protection'
            })
        
        return vulnerabilities

    def _check_lambda_vulnerabilities_detailed(self, function):
        """Detailed Lambda vulnerability checks"""
        vulnerabilities = []
        
        # Environment variables check
        env_vars = function.get('Environment', {}).get('Variables', {})
        if env_vars:
            # Check for potential secrets in environment variable names
            secret_keywords = ['password', 'secret', 'key', 'token', 'credential']
            has_potential_secrets = any(
                any(keyword in key.lower() for keyword in secret_keywords)
                for key in env_vars.keys()
            )
            
            if has_potential_secrets:
                vulnerabilities.append({
                    'id': 'LAMBDA-ENV-SECRETS',
                    'title': 'Potential Secrets in Environment Variables',
                    'severity': 'HIGH',
                    'description': 'Environment variables may contain sensitive data like passwords or API keys',
                    'remediation': 'Use AWS Secrets Manager for sensitive data instead of environment variables',
                    'category': 'Data Protection'
                })
        
        # Check if function has excessive permissions (simplified check)
        if function.get('Role'):
            vulnerabilities.append({
                'id': 'LAMBDA-POLICY-REVIEW',
                'title': 'Execution Role Needs Review',
                'severity': 'MEDIUM',
                'description': 'Lambda execution role should be reviewed for least privilege principles',
                'remediation': 'Review and restrict IAM permissions following least privilege',
                'category': 'IAM Security'
            })
        
        # Check if function is not in VPC but should be
        if not function.get('VpcConfig', {}).get('VpcId'):
            vulnerabilities.append({
                'id': 'LAMBDA-NO-VPC',
                'title': 'Lambda Function Not in VPC',
                'severity': 'LOW',
                'description': 'Function is not deployed in VPC, may access internet directly',
                'remediation': 'Consider deploying in VPC for enhanced network security',
                'category': 'Network Security'
            })
        
        return vulnerabilities

    def _get_resource_name(self, tags):
        """Extract name from resource tags"""
        for tag in tags:
            if tag['Key'] == 'Name':
                return tag['Value']
        return 'Unnamed'

    def _extract_vulnerabilities(self, resources):
        """Extract vulnerabilities from resources"""
        vulnerabilities = []
        for resource in resources:
            for vuln in resource.get('vulnerabilities', []):
                vuln_data = vuln.copy()
                vuln_data['resource_id'] = resource['resource_id']
                vuln_data['resource_type'] = resource['resource_type']
                vuln_data['resource_name'] = resource.get('name', resource['resource_id'])
                vuln_data['service'] = resource.get('service', 'Unknown')
                vulnerabilities.append(vuln_data)
        return vulnerabilities

    def run_basic_scan(self):
        """Basic scan fallback"""
        resources = self._get_demo_resources()
        vulnerabilities = self._extract_vulnerabilities(resources)
        
        st.session_state.scan_results = {
            'resources': resources,
            'vulnerabilities': vulnerabilities,
            'scan_time': datetime.now().isoformat(),
            'is_demo': True
        }

    def _get_demo_resources(self):
        """Get demo resources for testing"""
        # ... (keep your existing demo resources code)
        return []  # Simplified for brevity

    # ... (keep your existing AI analysis, display methods, and other functionality)

    def display_dashboard(self):
        st.markdown('<h1 class="main-header">üõ°Ô∏è AWS Vulnerability Remediation AI</h1>', unsafe_allow_html=True)
        
        # Sidebar with enhanced controls
        self.display_enhanced_sidebar()
        
        # Main content
        if st.session_state.scan_results is None:
            self.display_enhanced_welcome()
        else:
            self.display_enhanced_results()

    def display_enhanced_sidebar(self):
        with st.sidebar:
            st.header("üéØ Scan Controls")
            
            # Service selection
            st.subheader("üîß Select Services to Scan")
            services = ['EC2', 'EKS', 'Lambda', 'IAM']
            selected_services = st.multiselect(
                "AWS Services:",
                services,
                default=st.session_state.selected_services,
                help="Select which AWS services to scan for vulnerabilities"
            )
            
            # Region selection
            st.subheader("üåç AWS Region")
            regions = self.get_aws_regions()
            selected_region = st.selectbox(
                "Select Region:",
                regions,
                index=regions.index(os.getenv('AWS_REGION', 'us-east-1')) if os.getenv('AWS_REGION') in regions else 0
            )
            
            # Scan options
            st.subheader("‚öôÔ∏è Scan Options")
            deep_scan = st.checkbox("Deep Security Scan", False, help="Perform comprehensive security checks")
            include_compliance = st.checkbox("Include Compliance Checks", True)
            
            col1, col2 = st.columns(2)
            with col1:
                if st.button("üöÄ Run Comprehensive Scan", use_container_width=True, type="primary"):
                    st.session_state.selected_services = selected_services
                    self.run_comprehensive_scan(selected_services)
                    st.rerun()
            
            with col2:
                if st.button("üîÑ Quick Rescan", use_container_width=True):
                    self.run_comprehensive_scan(selected_services)
                    st.rerun()
            
            if st.session_state.scan_results:
                st.header("üîç Filters")
                vulnerabilities = st.session_state.scan_results['vulnerabilities']
                
                # Enhanced filters
                col1, col2 = st.columns(2)
                with col1:
                    # Resource type filter
                    resource_types = list(set([v['resource_type'] for v in vulnerabilities]))
                    selected_types = st.multiselect(
                        "Resource Types",
                        resource_types,
                        default=resource_types
                    )
                    
                    # Service filter
                    services = list(set([v.get('service', 'Unknown') for v in vulnerabilities]))
                    selected_services_filter = st.multiselect(
                        "Services",
                        services,
                        default=services
                    )
                
                with col2:
                    # Severity filter
                    severities = list(set([v['severity'] for v in vulnerabilities]))
                    selected_severities = st.multiselect(
                        "Severity Levels",
                        severities,
                        default=severities
                    )
                    
                    # Category filter
                    categories = list(set([v.get('category', 'General') for v in vulnerabilities]))
                    selected_categories = st.multiselect(
                        "Categories",
                        categories,
                        default=categories
                    )
                
                # Apply filters
                filtered_vulns = [
                    v for v in vulnerabilities 
                    if v['resource_type'] in selected_types 
                    and v['severity'] in selected_severities
                    and v.get('category', 'General') in selected_categories
                    and v.get('service', 'Unknown') in selected_services_filter
                ]
                
                st.session_state.filtered_vulnerabilities = filtered_vulns
                
                # Demo mode indicator
                if st.session_state.scan_results.get('is_demo'):
                    st.warning("üî∏ Demo Mode - Using sample data")
                else:
                    st.success("‚úÖ Live AWS Environment")

    def display_enhanced_welcome(self):
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.markdown("""
            <div style='text-align: center;'>
            <h2>üöÄ Welcome to AWS Vulnerability Remediation AI</h2>
            <p>Enterprise-grade cloud security with AI-powered automation</p>
            </div>
            """, unsafe_allow_html=True)
            
            # Service cards
            st.subheader("üõ°Ô∏è Protected Services")
            services_cols = st.columns(4)
            services = [
                ("üñ•Ô∏è", "EC2", "Instances, Security Groups, Volumes"),
                ("‚ò∏Ô∏è", "EKS", "Clusters, Pods, Control Plane"),
                ("Œª", "Lambda", "Functions, Permissions, Runtime"),
                ("üë§", "IAM", "Users, Roles, Policies")
            ]
            
            for col, (icon, name, desc) in zip(services_cols, services):
                with col:
                    st.markdown(f"""
                    <div class="service-card">
                        <h3>{icon}</h3>
                        <h4>{name}</h4>
                        <small>{desc}</small>
                    </div>
                    """, unsafe_allow_html=True)
            
            # Quick actions
            st.subheader("‚ö° Quick Actions")
            if st.button("üìä Run Security Assessment", use_container_width=True):
                self.run_comprehensive_scan(['EC2', 'EKS', 'Lambda'])
                st.rerun()
        
        with col2:
            st.info("""
            ## ‚ú® Enhanced Features
            
            **üîç Comprehensive Scanning**
            - Real-time AWS resource discovery
            - Detailed vulnerability assessment
            - Multi-service security checks
            
            **ü§ñ AI-Powered Analysis** 
            - AWS Bedrock integration
            - Intelligent remediation plans
            - Risk-based prioritization
            
            **‚ö° Automated Remediation**
            - One-click security fixes
            - Safe execution modes
            - Change verification
            
            **üìä Advanced Analytics**
            - Real-time dashboards
            - Trend analysis
            - Compliance reporting
            """)
            
            # Configuration status
            st.subheader("üîß Configuration Status")
            if self.aws_clients:
                st.success("‚úÖ AWS Credentials: Configured")
                if self.aws_clients.get('bedrock-runtime'):
                    st.success("‚úÖ AWS Bedrock: Available")
                else:
                    st.warning("‚ö†Ô∏è AWS Bedrock: Not available in this region")
            else:
                st.error("‚ùå AWS Credentials: Not configured")
                st.info("üí° Configure your AWS credentials in the .env file to enable live scanning")

    def display_enhanced_results(self):
        resources = st.session_state.scan_results['resources']
        vulnerabilities = st.session_state.get('filtered_vulnerabilities', [])
        
        # Enhanced metrics dashboard
        self.display_enhanced_metrics(resources, vulnerabilities)
        
        # Enhanced tabs with more options
        tab1, tab2, tab3, tab4, tab5 = st.tabs([
            "üìã Vulnerability Dashboard", 
            "üîß Resource Explorer", 
            "ü§ñ AI Analysis Center", 
            "‚ö° Remediation Hub",
            "üìä Security Insights"
        ])
        
        with tab1:
            self.display_enhanced_vulnerabilities_tab(vulnerabilities)
        
        with tab2:
            self.display_enhanced_resources_tab(resources)
        
        with tab3:
            self.display_enhanced_analysis_tab(vulnerabilities)
        
        with tab4:
            self.display_enhanced_remediation_tab(vulnerabilities)
        
        with tab5:
            self.display_security_insights_tab(resources, vulnerabilities)

    def display_enhanced_metrics(self, resources, vulnerabilities):
        st.subheader("üìä Security Dashboard Overview")
        
        # Main metrics
        col1, col2, col3, col4, col5 = st.columns(5)
        
        total_resources = len(resources)
        total_vulns = len(vulnerabilities)
        high_vulns = len([v for v in vulnerabilities if v['severity'] == 'HIGH'])
        medium_vulns = len([v for v in vulnerabilities if v['severity'] == 'MEDIUM'])
        critical_vulns = len([v for v in vulnerabilities if v['severity'] == 'CRITICAL'])
        
        with col1:
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("Total Resources", total_resources)
            st.markdown('</div>', unsafe_allow_html=True)
        
        with col2:
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("Total Vulnerabilities", total_vulns, delta_color="inverse")
            st.markdown('</div>', unsafe_allow_html=True)
        
        with col3:
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("üî¥ Critical", critical_vulns, delta_color="inverse")
            st.markdown('</div>', unsafe_allow_html=True)
        
        with col4:
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("üü† High", high_vulns, delta_color="inverse")
            st.markdown('</div>', unsafe_allow_html=True)
        
        with col5:
            st.markdown('<div class="metric-card">', unsafe_allow_html=True)
            st.metric("üü° Medium", medium_vulns, delta_color="inverse")
            st.markdown('</div>', unsafe_allow_html=True)
        
        # Service distribution
        st.subheader("üèóÔ∏è Resource Distribution by Service")
        service_counts = {}
        for resource in resources:
            service = resource.get('service', 'Unknown')
            service_counts[service] = service_counts.get(service, 0) + 1
        
        if service_counts:
            cols = st.columns(len(service_counts))
            for col, (service, count) in zip(cols, service_counts.items()):
                with col:
                    st.markdown(f"""
                    <div style='text-align: center; padding: 10px; background: #f0f2f6; border-radius: 10px;'>
                        <h3>{count}</h3>
                        <p><strong>{service}</strong></p>
                    </div>
                    """, unsafe_allow_html=True)

    def display_enhanced_vulnerabilities_tab(self, vulnerabilities):
        st.header("üìã Vulnerability Dashboard")
        
        if not vulnerabilities:
            st.info("üéâ No vulnerabilities found matching the current filters!")
            return
        
        # Vulnerability summary
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.subheader("üéØ Detected Vulnerabilities")
        
        with col2:
            st.metric("Filtered Count", len(vulnerabilities))
        
        # Display each vulnerability with enhanced details
        for idx, vuln in enumerate(vulnerabilities):
            severity_class = f"severity-{vuln['severity'].lower()}"
            
            with st.expander(f"{vuln['severity']} - {vuln['title']} - {vuln['resource_name']}", expanded=False):
                # Header with critical information
                col1, col2, col3 = st.columns([2, 1, 1])
                
                with col1:
                    st.markdown(f"**üîß Resource:** {vuln['service']} - `{vuln['resource_name']}`")
                    st.markdown(f"**üìä Severity:** <span class='{severity_class}'>{vuln['severity']}</span>", unsafe_allow_html=True)
                
                with col2:
                    st.markdown(f"**üìù Category:** {vuln.get('category', 'General')}")
                    st.markdown(f"**üÜî ID:** `{vuln['id']}`")
                
                with col3:
                    st.markdown(f"**üè∑Ô∏è Type:** {vuln['resource_type']}")
                    st.markdown(f"**üîç Service:** {vuln.get('service', 'Unknown')}")
                
                # Description and remediation
                col1, col2 = st.columns([1, 1])
                with col1:
                    st.markdown("**üìñ Description**")
                    st.info(vuln['description'])
                
                with col2:
                    st.markdown("**üõ†Ô∏è Recommended Action**")
                    st.warning(vuln.get('remediation', 'Review required'))
                
                # Resource-specific details
                if vuln.get('resource_specific'):
                    st.markdown("**üîç Resource Details**")
                    st.json(vuln['resource_specific'], expanded=False)
                
                # Action buttons
                col1, col2, col3, col4 = st.columns([2, 1, 1, 1])
                with col1:
                    if st.button(f"ü§ñ AI Analysis", key=f"analyze_{idx}", use_container_width=True):
                        if vuln not in st.session_state.selected_vulnerabilities:
                            st.session_state.selected_vulnerabilities.append(vuln)
                            st.success(f"‚úÖ Added {vuln['title']} to AI analysis queue!")
                
                with col2:
                    if st.button(f"‚≠ê Select", key=f"select_{idx}", use_container_width=True):
                        if vuln not in st.session_state.selected_vulnerabilities:
                            st.session_state.selected_vulnerabilities.append(vuln)
                            st.success(f"‚úÖ Selected for remediation!")
                
                with col3:
                    if st.button("üìã Details", key=f"details_{idx}", use_container_width=True):
                        st.json(vuln, expanded=False)
                
                with col4:
                    if st.button("üö® Ignore", key=f"ignore_{idx}", use_container_width=True):
                        st.warning(f"Ignored {vuln['title']}")

    def display_enhanced_resources_tab(self, resources):
        st.header("üîß Resource Explorer")
        
        if not resources:
            st.info("No resources found. Run a scan first!")
            return
        
        # Resource filtering
        col1, col2, col3 = st.columns(3)
        with col1:
            services = list(set([r.get('service', 'Unknown') for r in resources]))
            selected_service = st.selectbox("Filter by Service:", ["All"] + services)
        
        with col2:
            resource_types = list(set([r['resource_type'] for r in resources]))
            selected_type = st.selectbox("Filter by Type:", ["All"] + resource_types)
        
        with col3:
            search_term = st.text_input("Search Resources:", placeholder="Enter resource name or ID...")
        
        # Filter resources
        filtered_resources = resources
        if selected_service != "All":
            filtered_resources = [r for r in filtered_resources if r.get('service') == selected_service]
        if selected_type != "All":
            filtered_resources = [r for r in filtered_resources if r['resource_type'] == selected_type]
        if search_term:
            filtered_resources = [r for r in filtered_resources if search_term.lower() in str(r.get('name', '')).lower() or search_term.lower() in r['resource_id'].lower()]
        
        st.info(f"Showing {len(filtered_resources)} of {len(resources)} resources")
        
        # Display resources
        for resource in filtered_resources:
            with st.expander(f"{resource.get('service', 'Unknown')} - {resource.get('name', resource['resource_id'])}", expanded=False):
                self._display_resource_details(resource)

    def _display_resource_details(self, resource):
        """Display detailed resource information"""
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.markdown("**üìã Basic Information**")
            st.write(f"**Resource ID:** `{resource['resource_id']}`")
            st.write(f"**Type:** {resource['resource_type']}")
            st.write(f"**Service:** {resource.get('service', 'Unknown')}")
            st.write(f"**Name:** {resource.get('name', 'Unnamed')}")
            
            if resource.get('state'):
                st.write(f"**State:** {resource['state']}")
            if resource.get('status'):
                st.write(f"**Status:** {resource['status']}")
        
        with col2:
            st.markdown("**üîß Configuration**")
            # Display service-specific details
            if resource['resource_type'] == 'EC2':
                st.write(f"**Instance Type:** {resource.get('instance_type', 'N/A')}")
                st.write(f"**Launch Time:** {resource.get('launch_time', 'N/A')}")
                st.write(f"**Public IP:** {resource.get('public_ip', 'Not assigned')}")
                st.write(f"**VPC:** {resource.get('vpc_id', 'N/A')}")
            
            elif resource['resource_type'] == 'EKS':
                st.write(f"**Version:** {resource.get('version', 'N/A')}")
                st.write(f"**Endpoint:** {resource.get('endpoint', 'N/A')}")
                st.write(f"**Created:** {resource.get('created_at', 'N/A')}")
            
            elif resource['resource_type'] == 'Lambda':
                st.write(f"**Runtime:** {resource.get('runtime', 'N/A')}")
                st.write(f"**Memory:** {resource.get('memory_size', 'N/A')} MB")
                st.write(f"**Timeout:** {resource.get('timeout', 'N/A')} seconds")
        
        # Vulnerabilities section
        if resource.get('vulnerabilities'):
            st.markdown("**üö® Security Findings**")
            for vuln in resource['vulnerabilities']:
                severity_class = f"severity-{vuln['severity'].lower()}"
                st.markdown(f"""
                <div class="vulnerability-item" style="border-left-color: {self._get_severity_color(vuln['severity'])}">
                    <strong>{vuln['title']}</strong> - <span class="{severity_class}">{vuln['severity']}</span><br>
                    <small>{vuln['description']}</small>
                </div>
                """, unsafe_allow_html=True)
        else:
            st.success("‚úÖ No vulnerabilities detected for this resource")

    def _get_severity_color(self, severity):
        """Get color for severity level"""
        colors = {
            'CRITICAL': '#FF0000',
            'HIGH': '#FF4B4B',
            'MEDIUM': '#FFA500',
            'LOW': '#008000',
            'INFO': '#0066CC'
        }
        return colors.get(severity, '#666666')

    def display_enhanced_analysis_tab(self, vulnerabilities):
        st.header("ü§ñ AI Analysis Center")
        
        if not vulnerabilities:
            st.info("üìù No vulnerabilities available for analysis. Run a scan first!")
            return
        
        # Analysis options
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.subheader("üîÆ AI-Powered Security Analysis")
            st.info("Get detailed AI analysis and remediation guidance for detected vulnerabilities")
        
        with col2:
            analysis_mode = st.selectbox(
                "Analysis Mode:",
                ["Single Vulnerability", "Batch Analysis", "Risk Assessment"]
            )
        
        # Selected vulnerabilities section
        selected_vulns = st.session_state.selected_vulnerabilities
        
        if selected_vulns:
            st.subheader("üìã Selected for Analysis")
            
            for idx, vuln in enumerate(selected_vulns):
                col1, col2, col3 = st.columns([3, 1, 1])
                with col1:
                    severity_class = f"severity-{vuln['severity'].lower()}"
                    st.markdown(f"**{vuln['title']}** - `{vuln['resource_name']}` - <span class='{severity_class}'>{vuln['severity']}</span>", unsafe_allow_html=True)
                
                with col2:
                    if st.button(f"üß† Analyze", key=f"run_analysis_{idx}"):
                        with st.spinner(f"Analyzing {vuln['title']}..."):
                            resource_context = next(
                                (r for r in st.session_state.scan_results['resources'] 
                                 if r['resource_id'] == vuln['resource_id']),
                                {}
                            )
                            # Here you would call your AI analysis method
                            st.success(f"Analysis completed for {vuln['title']}")
                
                with col3:
                    if st.button(f"‚ùå Remove", key=f"remove_analysis_{idx}"):
                        st.session_state.selected_vulnerabilities.remove(vuln)
                        st.rerun()
            
            st.divider()
        
        # Quick analysis for individual vulnerabilities
        st.subheader("üöÄ Quick Analysis")
        quick_vuln = st.selectbox(
            "Select a vulnerability for instant analysis:",
            options=vulnerabilities,
            format_func=lambda x: f"{x['severity']} - {x['title']} - {x['resource_name']}"
        )
        
        if quick_vuln and st.button("ü§ñ Analyze This Vulnerability", use_container_width=True):
            with st.spinner("üîÆ AI is analyzing the vulnerability..."):
                resource_context = next(
                    (r for r in st.session_state.scan_results['resources'] 
                     if r['resource_id'] == quick_vuln['resource_id']),
                    {}
                )
                # Call your AI analysis method here
                analysis_result = self._simulate_ai_analysis(quick_vuln, resource_context)
                self._display_enhanced_analysis_results(quick_vuln, analysis_result)

    def _display_enhanced_analysis_results(self, vulnerability, analysis):
        """Display enhanced AI analysis results"""
        st.markdown(f"### üìä AI Analysis: {vulnerability['title']}")
        
        # Risk assessment with visual indicators
        st.markdown("#### üìà Risk Assessment")
        col1, col2 = st.columns([3, 1])
        with col1:
            st.info(analysis.get('risk_assessment', 'No risk assessment available'))
        with col2:
            severity = vulnerability['severity']
            st.markdown(f"<div style='text-align: center; padding: 10px; background: {self._get_severity_color(severity)}; color: white; border-radius: 5px;'><strong>{severity}</strong></div>", unsafe_allow_html=True)
        
        # Remediation steps
        st.markdown("#### üõ†Ô∏è Remediation Steps")
        steps = analysis.get('remediation_steps', [])
        if steps:
            for i, step in enumerate(steps, 1):
                st.write(f"**{i}.** {step}")
        else:
            st.warning("No specific remediation steps provided")
        
        # AWS Commands
        st.markdown("#### üíª AWS CLI Commands")
        commands = analysis.get('aws_commands', [])
        if commands:
            for cmd in commands:
                st.code(cmd, language='bash')
        else:
            st.info("No AWS commands provided")
        
        # Impact and verification in columns
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("#### ‚ö†Ô∏è Potential Impact")
            st.warning(analysis.get('impact', 'Impact assessment not available'))
        
        with col2:
            st.markdown("#### ‚úÖ Verification Steps")
            verification = analysis.get('verification', [])
            if verification:
                for step in verification:
                    st.write(f"‚Ä¢ {step}")
            else:
                st.info("No verification steps provided")
        
        st.divider()

    def display_enhanced_remediation_tab(self, vulnerabilities):
        st.header("‚ö° Remediation Hub")
        
        selected_vulns = st.session_state.selected_vulnerabilities
        
        if not selected_vulns:
            st.info("üéØ No vulnerabilities selected for remediation. Select vulnerabilities from the Vulnerability Dashboard.")
            return
        
        # Remediation overview
        st.subheader("üéØ Selected for Remediation")
        
        total_risk_score = sum([self._get_risk_score(v['severity']) for v in selected_vulns])
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Selected Items", len(selected_vulns))
        with col2:
            st.metric("Total Risk Score", total_risk_score)
        with col3:
            critical_count = len([v for v in selected_vulns if v['severity'] in ['CRITICAL', 'HIGH']])
            st.metric("Critical/High", critical_count)
        
        # Display selected vulnerabilities
        for idx, vuln in enumerate(selected_vulns):
            col1, col2, col3 = st.columns([4, 1, 1])
            with col1:
                severity_class = f"severity-{vuln['severity'].lower()}"
                st.markdown(f"""
                **{vuln['title']}** 
                - `{vuln['resource_name']}` 
                - <span class='{severity_class}'>{vuln['severity']}</span>
                - {vuln.get('category', 'General')}
                """, unsafe_allow_html=True)
            with col2:
                if st.button("üìã Plan", key=f"plan_{idx}"):
                    st.session_state.remediation_plan = self._generate_remediation_plan([vuln])
                    st.success("Remediation plan generated!")
            with col3:
                if st.button("üóëÔ∏è Remove", key=f"remove_remediation_{idx}"):
                    st.session_state.selected_vulnerabilities.remove(vuln)
                    st.rerun()
        
        # Remediation actions
        st.subheader("üöÄ Remediation Actions")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            if st.button("üìã Generate Plan", use_container_width=True, icon="üìã"):
                st.session_state.remediation_plan = self._generate_remediation_plan(selected_vulns)
                st.success("‚úÖ Comprehensive remediation plan generated!")
        
        with col2:
            if st.button("üîç Preview Changes", use_container_width=True, icon="üîç"):
                st.info("üîç Change preview would show here in production")
        
        with col3:
            if st.button("üß™ Dry Run", use_container_width=True, icon="üß™"):
                st.warning("üß™ Dry run mode - no changes will be made")
        
        with col4:
            if st.button("‚ö° Execute", type="primary", use_container_width=True, icon="‚ö°"):
                self._execute_remediation(selected_vulns)
        
        # Show remediation history
        if st.session_state.remediation_results:
            st.subheader("üìú Remediation History")
            for result_id, result in st.session_state.remediation_results.items():
                status = result.get('status', 'unknown')
                if status == 'success':
                    st.success(f"‚úÖ {result_id}: {result.get('message', 'Completed')}")
                elif status == 'error':
                    st.error(f"‚ùå {result_id}: {result.get('message', 'Failed')}")
                else:
                    st.info(f"‚ÑπÔ∏è {result_id}: {result.get('message', 'Unknown status')}")

    def display_security_insights_tab(self, resources, vulnerabilities):
        st.header("üìä Security Insights & Analytics")
        
        if not vulnerabilities:
            st.info("Run a security scan to see insights and analytics")
            return
        
        # Security score
        total_vulns = len(vulnerabilities)
        critical_vulns = len([v for v in vulnerabilities if v['severity'] == 'CRITICAL'])
        high_vulns = len([v for v in vulnerabilities if v['severity'] == 'HIGH'])
        
        security_score = max(0, 100 - (critical_vulns * 10 + high_vulns * 5 + (total_vulns - critical_vulns - high_vulns) * 2))
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Overall Security Score", f"{security_score}/100")
        with col2:
            st.metric("Resources Scanned", len(resources))
        with col3:
            st.metric("Vulnerability Density", f"{(total_vulns/len(resources))*100:.1f}%" if resources else "0%")
        
        # Vulnerability distribution
        st.subheader("üìà Vulnerability Distribution")
        
        # By severity
        severity_counts = {}
        for vuln in vulnerabilities:
            severity_counts[vuln['severity']] = severity_counts.get(vuln['severity'], 0) + 1
        
        if severity_counts:
            cols = st.columns(len(severity_counts))
            for col, (severity, count) in zip(cols, severity_counts.items()):
                with col:
                    color = self._get_severity_color(severity)
                    percentage = (count / total_vulns) * 100
                    st.markdown(f"""
                    <div style='text-align: center; padding: 15px; background: {color}20; border: 2px solid {color}; border-radius: 10px;'>
                        <h3 style='color: {color}; margin: 0;'>{count}</h3>
                        <p style='margin: 5px 0; font-weight: bold;'>{severity}</p>
                        <small>{percentage:.1f}%</small>
                    </div>
                    """, unsafe_allow_html=True)
        
        # By service
        st.subheader("üèóÔ∏è Vulnerabilities by Service")
        service_vulns = {}
        for vuln in vulnerabilities:
            service = vuln.get('service', 'Unknown')
            service_vulns[service] = service_vulns.get(service, 0) + 1
        
        if service_vulns:
            for service, count in service_vulns.items():
                st.write(f"**{service}:** {count} vulnerabilities")
        
        # Recommendations
        st.subheader("üí° Security Recommendations")
        
        if critical_vulns > 0:
            st.error(f"**Priority Action:** Address {critical_vulns} critical vulnerabilities immediately")
        if high_vulns > 0:
            st.warning(f"**Important:** Resolve {high_vulns} high-severity vulnerabilities")
        
        if security_score >= 80:
            st.success("**Good:** Your security posture is strong. Maintain current practices.")
        elif security_score >= 60:
            st.warning("**Needs Improvement:** Address medium and high severity issues.")
        else:
            st.error("**Critical:** Immediate attention required for security issues.")

    def _get_risk_score(self, severity):
        """Calculate risk score based on severity"""
        scores = {
            'CRITICAL': 10,
            'HIGH': 8,
            'MEDIUM': 5,
            'LOW': 2,
            'INFO': 1
        }
        return scores.get(severity, 1)

    def _generate_remediation_plan(self, vulnerabilities):
        """Generate a detailed remediation plan"""
        plan = {
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': vulnerabilities,
            'steps': [],
            'estimated_duration': '15-30 minutes',
            'risk_level': 'Medium'
        }
        
        for vuln in vulnerabilities:
            plan['steps'].append({
                'vulnerability': vuln['id'],
                'resource': vuln['resource_id'],
                'action': f"Remediate {vuln['title']}",
                'estimated_time': '5-10 minutes',
                'risk': vuln['severity'],
                'priority': 'High' if vuln['severity'] in ['CRITICAL', 'HIGH'] else 'Medium'
            })
        
        return plan

    def _execute_remediation(self, vulnerabilities):
        """Execute remediation for selected vulnerabilities"""
        progress_bar = st.progress(0)
        status_text = st.empty()
        results = st.container()
        
        for i, vuln in enumerate(vulnerabilities):
            status_text.text(f"üîÑ Remediating {vuln['title']}...")
            
            # Simulate remediation process
            import time
            time.sleep(2)  # Simulate processing time
            
            # Simulate result
            result = {
                'status': 'success',
                'message': f'Successfully remediated {vuln["id"]} on {vuln["resource_id"]}',
                'timestamp': datetime.now().isoformat()
            }
            
            result_id = f"{vuln['resource_id']}_{vuln['id']}"
            st.session_state.remediation_results[result_id] = result
            
            progress_bar.progress((i + 1) / len(vulnerabilities))
            
            with results:
                st.success(f"‚úÖ {vuln['title']} - Remediation completed")
        
        status_text.text("üéâ All remediations completed!")
        st.balloons()

    def _simulate_ai_analysis(self, vulnerability, resource_context):
        """Simulate AI analysis - replace with actual Bedrock calls"""
        return {
            'risk_assessment': f"AI analysis for {vulnerability['title']} - This is a simulated response. With real AWS Bedrock, you would get detailed AI-powered security analysis.",
            'remediation_steps': [
                '1. Review the specific security finding',
                '2. Implement AWS best practices',
                '3. Test the remediation in staging',
                '4. Deploy to production',
                '5. Verify the fix'
            ],
            'aws_commands': [
                f'# Command to remediate {vulnerability["id"]}',
                '# Actual AWS CLI commands would appear here with real Bedrock integration'
            ],
            'impact': 'Simulated impact assessment - real Bedrock would provide detailed impact analysis',
            'verification': [
                'Verify the remediation in AWS console',
                'Check security scan results',
                'Validate functionality'
            ]
        }

def main():
    app = AWSVulnerabilityApp()
    app.display_dashboard()

if __name__ == "__main__":
    main()