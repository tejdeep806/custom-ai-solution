import streamlit as st
import boto3
import json
from datetime import datetime
from typing import Dict, List, Any
import os
from dotenv import load_dotenv
import time

# Load environment variables at the start
load_dotenv()

# Set page config FIRST - this must be the first Streamlit command
st.set_page_config(
    page_title="AWS Vulnerability Remediation AI",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS - after page config
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #FF4B4B;
        text-align: center;
        margin-bottom: 2rem;
    }
    .severity-critical { background-color: #FF0000; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-high { background-color: #FF4B4B; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-medium { background-color: #FFA500; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-low { background-color: #008000; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-info { background-color: #0066CC; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    
    .resource-card { 
        border-left: 5px solid #FF4B4B; 
        padding: 15px; 
        margin: 10px 0; 
        background-color: #f0f2f6;
        border-radius: 5px;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        margin: 5px;
        border: 1px solid #ddd;
    }
    .service-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        margin: 5px;
        height: 120px;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    .service-card h4 {
        margin: 5px 0;
        font-size: 1.1rem;
    }
    .service-card small {
        font-size: 0.8rem;
        opacity: 0.9;
    }
    .vulnerability-item {
        border-left: 4px solid;
        padding: 10px;
        margin: 5px 0;
        background-color: #f8f9fa;
        border-radius: 5px;
    }
    .success-box { background-color: #d4edda; border-left: 5px solid #28a745; padding: 15px; border-radius: 5px; }
    .warning-box { background-color: #fff3cd; border-left: 5px solid #ffc107; padding: 15px; border-radius: 5px; }
    .error-box { background-color: #f8d7da; border-left: 5px solid #dc3545; padding: 15px; border-radius: 5px; }
    .info-box { background-color: #d1ecf1; border-left: 5px solid #17a2b8; padding: 15px; border-radius: 5px; }
    
    .credentials-status {
        background-color: #e7f3ff;
        padding: 10px;
        border-radius: 5px;
        border-left: 4px solid #17a2b8;
        margin: 10px 0;
        font-size: 0.9rem;
    }
    
    .tab-content {
        padding: 20px;
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 10px 0;
    }
    
    .resource-details {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border-left: 4px solid #007bff;
    }
    
    .remediation-step {
        background-color: #f8f9fa;
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #28a745;
    }
    
    .security-tip {
        background-color: #e7f3ff;
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #17a2b8;
    }
</style>
""", unsafe_allow_html=True)

class AWSSecretsManager:
    def __init__(self):
        self.secrets_client = None
        self.initialize_secrets_client()
    
    def initialize_secrets_client(self):
        """Initialize Secrets Manager client with fallback options"""
        try:
            # Try to initialize with environment variables first
            access_key = os.getenv('AWS_ACCESS_KEY_ID')
            secret_key = os.getenv('AWS_SECRET_ACCESS_KEY')
            region = os.getenv('AWS_REGION', 'us-east-1')
            
            if access_key and secret_key:
                self.secrets_client = boto3.client(
                    'secretsmanager',
                    aws_access_key_id=access_key,
                    aws_secret_access_key=secret_key,
                    region_name=region
                )
                return True
            else:
                # Try with IAM role (for EC2/ECS/Lambda)
                self.secrets_client = boto3.client('secretsmanager', region_name=region)
                return True
                
        except Exception as e:
            print(f"Failed to initialize Secrets Manager: {str(e)}")
            self.secrets_client = None
            return False
    
    def get_secret(self, secret_arn):
        """Retrieve secret from AWS Secrets Manager"""
        if not self.secrets_client:
            print("Secrets Manager client not initialized")
            return None
        
        try:
            response = self.secrets_client.get_secret_value(SecretId=secret_arn)
            
            if 'SecretString' in response:
                secret_data = json.loads(response['SecretString'])
                return secret_data
            else:
                print("Secret found but no SecretString available")
                return None
                
        except Exception as e:
            print(f"Failed to retrieve secret from {secret_arn}: {str(e)}")
            return None

class AWSVulnerabilityApp:
    def __init__(self):
        # Initialize Secrets Manager
        self.secrets_manager = AWSSecretsManager()
        
        # Initialize session state variables
        if 'scan_results' not in st.session_state:
            st.session_state.scan_results = None
        if 'selected_vulnerabilities' not in st.session_state:
            st.session_state.selected_vulnerabilities = []
        if 'remediation_results' not in st.session_state:
            st.session_state.remediation_results = {}
        if 'ai_analysis_cache' not in st.session_state:
            st.session_state.ai_analysis_cache = {}
        if 'remediation_plan' not in st.session_state:
            st.session_state.remediation_plan = None
        if 'selected_services' not in st.session_state:
            st.session_state.selected_services = ['EC2', 'EKS', 'Lambda']
        if 'scan_details' not in st.session_state:
            st.session_state.scan_details = {}
        if 'execution_mode' not in st.session_state:
            st.session_state.execution_mode = 'dry-run'
        if 'aws_credentials' not in st.session_state:
            st.session_state.aws_credentials = None
            
        # Try to load credentials from Secrets Manager
        self.load_credentials_from_secrets_manager()
        
        # Initialize AWS clients with retrieved credentials
        self.aws_clients = self._setup_aws_clients()
    
    def load_credentials_from_secrets_manager(self):
        """Load AWS credentials from Secrets Manager"""
        # Your Secrets Manager ARN
        SECRET_ARN = "arn:aws:secretsmanager:us-east-1:736496772981:secret:awsusercreds-IoJQmU"
        
        # Check if we already have credentials
        if st.session_state.aws_credentials is None:
            credentials = self.secrets_manager.get_secret(SECRET_ARN)
            if credentials:
                st.session_state.aws_credentials = credentials
    
    def _setup_aws_clients(self):
        """Setup AWS clients using credentials from Secrets Manager"""
        try:
            if not st.session_state.aws_credentials:
                return None
            
            credentials = st.session_state.aws_credentials
            region = credentials.get('AWS_REGION', 'us-east-1')
            
            # Validate required credentials
            access_key = credentials.get('AWS_ACCESS_KEY_ID')
            secret_key = credentials.get('AWS_SECRET_ACCESS_KEY')
            
            if not access_key or not secret_key:
                return None
            
            session = boto3.Session(
                aws_access_key_id=access_key,
                aws_secret_access_key=secret_key,
                region_name=region
            )
            
            clients = {
                'ec2': session.client('ec2'),
                'eks': session.client('eks'), 
                'lambda': session.client('lambda'),
                'securityhub': session.client('securityhub'),
                'iam': session.client('iam'),
                's3': session.client('s3'),
            }
            
            # Try to setup Bedrock
            try:
                clients['bedrock-runtime'] = session.client('bedrock-runtime', region_name=region)
            except:
                clients['bedrock-runtime'] = None
                
            return clients
            
        except Exception as e:
            print(f"AWS setup failed: {str(e)}")
            return None

    def display_credentials_status(self):
        """Display current credentials status in a minimal way"""
        if st.session_state.aws_credentials:
            credentials = st.session_state.aws_credentials
            access_key = credentials.get('AWS_ACCESS_KEY_ID', '')
            masked_key = access_key[:10] + '...' if len(access_key) > 10 else access_key
            
            st.markdown(f"""
            <div class="credentials-status">
                <strong>üîê AWS Credentials Loaded</strong> | 
                <strong>Region:</strong> {credentials.get('AWS_REGION', 'us-east-1')}
            </div>
            """, unsafe_allow_html=True)

    def refresh_credentials(self):
        """Refresh credentials from Secrets Manager"""
        st.session_state.aws_credentials = None
        self.load_credentials_from_secrets_manager()
        self.aws_clients = self._setup_aws_clients()
        st.rerun()

    def run_comprehensive_scan(self, selected_services):
        """Run comprehensive AWS security scan"""
        try:
            if not self.aws_clients:
                st.warning("üö® No AWS credentials available. Using demo data.")
                self.run_basic_scan()
                return
            
            # Show scanning progress
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            scan_details = {}
            total_resources = 0
            
            steps = len(selected_services)
            current_step = 0
            
            if 'EC2' in selected_services:
                current_step += 1
                status_text.text(f"üñ•Ô∏è Scanning EC2 Instances... ({current_step}/{steps})")
                progress_bar.progress(current_step/steps)
                ec2_resources = self._scan_ec2_detailed()
                scan_details['EC2'] = ec2_resources
                total_resources += len(ec2_resources)
            
            if 'EKS' in selected_services:
                current_step += 1
                status_text.text(f"‚ò∏Ô∏è Scanning EKS Clusters... ({current_step}/{steps})")
                progress_bar.progress(current_step/steps)
                eks_resources = self._scan_eks_detailed()
                scan_details['EKS'] = eks_resources
                total_resources += len(eks_resources)
            
            if 'Lambda' in selected_services:
                current_step += 1
                status_text.text(f"Œª Scanning Lambda Functions... ({current_step}/{steps})")
                progress_bar.progress(current_step/steps)
                lambda_resources = self._scan_lambda_detailed()
                scan_details['Lambda'] = lambda_resources
                total_resources += len(lambda_resources)
            
            if 'IAM' in selected_services:
                current_step += 1
                status_text.text(f"üë§ Scanning IAM Resources... ({current_step}/{steps})")
                progress_bar.progress(current_step/steps)
                iam_findings = self._scan_iam_detailed()
                scan_details['IAM'] = iam_findings
                total_resources += len(iam_findings)
            
            if 'S3' in selected_services:
                current_step += 1
                status_text.text(f"ü™£ Scanning S3 Buckets... ({current_step}/{steps})")
                progress_bar.progress(current_step/steps)
                s3_findings = self._scan_s3_detailed()
                scan_details['S3'] = s3_findings
                total_resources += len(s3_findings)
            
            # Combine all resources
            all_resources = []
            for service_resources in scan_details.values():
                all_resources.extend(service_resources)
            
            vulnerabilities = self._extract_vulnerabilities(all_resources)
            
            st.session_state.scan_results = {
                'resources': all_resources,
                'vulnerabilities': vulnerabilities,
                'scan_time': datetime.now().isoformat(),
                'is_demo': False,
                'scan_details': scan_details,
                'total_resources': total_resources
            }
            
            progress_bar.progress(1.0)
            status_text.text("‚úÖ Scan completed!")
            
            # Show results
            st.success(f"üéØ Found {total_resources} resources and {len(vulnerabilities)} vulnerabilities")
            
        except Exception as e:
            st.error(f"‚ùå Scan failed: {str(e)}")
            self.run_basic_scan()

    def _scan_ec2_detailed(self):
        """Scan EC2 instances"""
        resources = []
        try:
            ec2 = self.aws_clients['ec2']
            response = ec2.describe_instances()
            
            for reservation in response['Reservations']:
                for instance in reservation['Instances']:
                    instance_details = {
                        'resource_id': instance['InstanceId'],
                        'resource_type': 'EC2',
                        'service': 'EC2',
                        'name': self._get_resource_name(instance.get('Tags', [])),
                        'state': instance['State']['Name'],
                        'instance_type': instance.get('InstanceType', 'N/A'),
                        'public_ip': instance.get('PublicIpAddress', 'Not Assigned'),
                        'vulnerabilities': self._check_ec2_vulnerabilities(instance)
                    }
                    resources.append(instance_details)
            
        except Exception as e:
            st.error(f"EC2 scan error: {str(e)}")
        
        return resources

    def _scan_eks_detailed(self):
        """Scan EKS clusters"""
        resources = []
        try:
            eks = self.aws_clients['eks']
            clusters = eks.list_clusters()
            
            for cluster_name in clusters.get('clusters', []):
                cluster_info = eks.describe_cluster(name=cluster_name)
                cluster_data = cluster_info['cluster']
                
                cluster_details = {
                    'resource_id': cluster_data['name'],
                    'resource_type': 'EKS',
                    'service': 'EKS',
                    'name': cluster_data['name'],
                    'status': cluster_data['status'],
                    'version': cluster_data['version'],
                    'vulnerabilities': self._check_eks_vulnerabilities(cluster_data)
                }
                resources.append(cluster_details)
            
        except Exception as e:
            st.error(f"EKS scan error: {str(e)}")
        
        return resources

    def _scan_lambda_detailed(self):
        """Scan Lambda functions"""
        resources = []
        try:
            lambda_client = self.aws_clients['lambda']
            response = lambda_client.list_functions()
            
            for function in response['Functions']:
                function_details = {
                    'resource_id': function['FunctionName'],
                    'resource_type': 'Lambda',
                    'service': 'Lambda',
                    'name': function['FunctionName'],
                    'runtime': function.get('Runtime', 'N/A'),
                    'vulnerabilities': self._check_lambda_vulnerabilities(function)
                }
                resources.append(function_details)
            
        except Exception as e:
            st.error(f"Lambda scan error: {str(e)}")
        
        return resources

    def _scan_iam_detailed(self):
        """Scan IAM resources"""
        findings = []
        try:
            iam = self.aws_clients['iam']
            # Basic IAM check - you can expand this
            findings.append({
                'resource_id': 'IAM-ROOT',
                'resource_type': 'IAM',
                'service': 'IAM',
                'name': 'Root User Check',
                'vulnerabilities': [{
                    'id': 'IAM-ROOT-ACCESS',
                    'title': 'Root Access Monitoring',
                    'severity': 'MEDIUM',
                    'description': 'Monitor root user access and usage',
                    'remediation': 'Enable IAM Access Analyzer and monitor root activity',
                    'category': 'IAM Security'
                }]
            })
            
        except Exception as e:
            st.error(f"IAM scan error: {str(e)}")
        
        return findings

    def _scan_s3_detailed(self):
        """Scan S3 buckets"""
        findings = []
        try:
            s3 = self.aws_clients['s3']
            buckets = s3.list_buckets()
            
            for bucket in buckets.get('Buckets', []):
                bucket_name = bucket['Name']
                findings.append({
                    'resource_id': bucket_name,
                    'resource_type': 'S3',
                    'service': 'S3',
                    'name': bucket_name,
                    'vulnerabilities': [{
                        'id': 'S3-PUBLIC-CHECK',
                        'title': 'S3 Bucket Security',
                        'severity': 'MEDIUM',
                        'description': f'Review S3 bucket {bucket_name} for public access',
                        'remediation': 'Enable S3 Block Public Access and review bucket policies',
                        'category': 'Data Protection'
                    }]
                })
            
        except Exception as e:
            st.error(f"S3 scan error: {str(e)}")
        
        return findings

    def _check_ec2_vulnerabilities(self, instance):
        """Check EC2 vulnerabilities"""
        vulnerabilities = []
        
        if instance.get('PublicIpAddress'):
            vulnerabilities.append({
                'id': 'EC2-PUBLIC-IP',
                'title': 'EC2 Instance with Public IP',
                'severity': 'HIGH',
                'description': 'Instance has public IP and is accessible from internet',
                'remediation': 'Move to private subnet or remove public IP',
                'category': 'Network Security'
            })
        
        return vulnerabilities

    def _check_eks_vulnerabilities(self, cluster):
        """Check EKS vulnerabilities"""
        vulnerabilities = []
        
        logging = cluster.get('logging', {}).get('clusterLogging', [{}])[0]
        if not logging.get('enabled', False):
            vulnerabilities.append({
                'id': 'EKS-LOGGING-DISABLED',
                'title': 'Control Plane Logging Disabled',
                'severity': 'MEDIUM',
                'description': 'EKS control plane logging is not enabled',
                'remediation': 'Enable control plane logging',
                'category': 'Logging & Monitoring'
            })
        
        return vulnerabilities

    def _check_lambda_vulnerabilities(self, function):
        """Check Lambda vulnerabilities"""
        vulnerabilities = []
        
        env_vars = function.get('Environment', {}).get('Variables', {})
        if env_vars:
            vulnerabilities.append({
                'id': 'LAMBDA-ENV-VARS',
                'title': 'Environment Variables Present',
                'severity': 'LOW',
                'description': 'Lambda function uses environment variables',
                'remediation': 'Review for sensitive data and consider using Secrets Manager',
                'category': 'Data Protection'
            })
        
        return vulnerabilities

    def _get_resource_name(self, tags):
        """Extract name from resource tags"""
        for tag in tags:
            if tag['Key'] == 'Name':
                return tag['Value']
        return 'Unnamed'

    def _extract_vulnerabilities(self, resources):
        """Extract vulnerabilities from resources"""
        vulnerabilities = []
        for resource in resources:
            for vuln in resource.get('vulnerabilities', []):
                vuln_data = vuln.copy()
                vuln_data['resource_id'] = resource['resource_id']
                vuln_data['resource_type'] = resource['resource_type']
                vuln_data['resource_name'] = resource.get('name', resource['resource_id'])
                vuln_data['service'] = resource.get('service', 'Unknown')
                vulnerabilities.append(vuln_data)
        return vulnerabilities

    def run_basic_scan(self):
        """Basic scan fallback with demo data"""
        resources = [
            {
                'resource_id': 'i-1234567890abcdef0',
                'resource_type': 'EC2',
                'service': 'EC2',
                'name': 'web-server-1',
                'state': 'running',
                'vulnerabilities': [
                    {
                        'id': 'EC2-PUBLIC-IP',
                        'title': 'EC2 Instance with Public IP',
                        'severity': 'HIGH',
                        'description': 'Instance has public IP and is accessible from internet',
                        'remediation': 'Move to private subnet or remove public IP',
                        'category': 'Network Security'
                    }
                ]
            },
            {
                'resource_id': 'my-eks-cluster',
                'resource_type': 'EKS',
                'service': 'EKS',
                'name': 'production-cluster',
                'status': 'ACTIVE',
                'vulnerabilities': [
                    {
                        'id': 'EKS-LOGGING-DISABLED',
                        'title': 'Control Plane Logging Disabled',
                        'severity': 'MEDIUM',
                        'description': 'EKS control plane logging is not enabled',
                        'remediation': 'Enable control plane logging',
                        'category': 'Logging & Monitoring'
                    }
                ]
            }
        ]
        
        vulnerabilities = self._extract_vulnerabilities(resources)
        
        st.session_state.scan_results = {
            'resources': resources,
            'vulnerabilities': vulnerabilities,
            'scan_time': datetime.now().isoformat(),
            'is_demo': True
        }

    def display_dashboard(self):
        st.markdown('<h1 class="main-header">üõ°Ô∏è AWS Vulnerability Remediation AI</h1>', unsafe_allow_html=True)
        
        # Display minimal credentials status
        self.display_credentials_status()
        
        # Sidebar
        self.display_sidebar()
        
        # Main content
        if st.session_state.scan_results is None:
            self.display_welcome()
        else:
            self.display_results()

    def display_sidebar(self):
        with st.sidebar:
            st.header("üéØ Scan Controls")
            
            # Service selection
            st.subheader("üîß Services to Scan")
            services = ['EC2', 'EKS', 'Lambda', 'IAM', 'S3']
            selected_services = st.multiselect(
                "Select services:",
                services,
                default=st.session_state.selected_services
            )
            
            col1, col2 = st.columns(2)
            with col1:
                if st.button("üöÄ Run Scan", use_container_width=True, type="primary"):
                    st.session_state.selected_services = selected_services
                    self.run_comprehensive_scan(selected_services)
            
            with col2:
                if st.button("üîÑ Quick Scan", use_container_width=True):
                    self.run_basic_scan()
            
            # Execution mode
            st.subheader("üîí Execution Mode")
            execution_mode = st.radio(
                "Remediation Mode:",
                ["Dry Run (Safe)", "Execute (Live)"],
                index=0
            )
            st.session_state.execution_mode = 'dry-run' if execution_mode == "Dry Run (Safe)" else 'execute'
            
            if st.session_state.scan_results:
                st.header("üîç Filters")
                vulnerabilities = st.session_state.scan_results['vulnerabilities']
                
                # Resource type filter
                resource_types = list(set([v['resource_type'] for v in vulnerabilities]))
                selected_types = st.multiselect(
                    "Resource Types",
                    resource_types,
                    default=resource_types
                )
                
                # Severity filter
                severities = list(set([v['severity'] for v in vulnerabilities]))
                selected_severities = st.multiselect(
                    "Severity Levels",
                    severities,
                    default=severities
                )
                
                # Apply filters
                filtered_vulns = [
                    v for v in vulnerabilities 
                    if v['resource_type'] in selected_types 
                    and v['severity'] in selected_severities
                ]
                
                st.session_state.filtered_vulnerabilities = filtered_vulns

    def display_welcome(self):
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.markdown("""
            <div style='text-align: center;'>
            <h2>üöÄ AWS Security Scanner</h2>
            <p>Automated vulnerability detection and remediation</p>
            </div>
            """, unsafe_allow_html=True)
            
            # Service cards with proper sizing
            st.subheader("üõ°Ô∏è Protected Services")
            services_cols = st.columns(2)
            services = [
                ("üñ•Ô∏è", "EC2", "Compute Instances"),
                ("‚ò∏Ô∏è", "EKS", "Kubernetes"),
                ("Œª", "Lambda", "Serverless"),
                ("ü™£", "S3", "Storage")
            ]
            
            # Display 2 services per row
            for i, (icon, name, desc) in enumerate(services):
                col = services_cols[i % 2]
                with col:
                    st.markdown(f"""
                    <div class="service-card">
                        <h3>{icon}</h3>
                        <h4>{name}</h4>
                        <small>{desc}</small>
                    </div>
                    """, unsafe_allow_html=True)
            
            if st.button("üìä Start Security Assessment", use_container_width=True, type="primary"):
                self.run_comprehensive_scan(['EC2', 'EKS', 'Lambda'])
        
        with col2:
            st.info("""
            ## ‚ú® Features
            
            **üîç Comprehensive Scanning**
            - Multi-service security assessment
            - Real-time vulnerability detection
            - Detailed risk analysis
            
            **ü§ñ AI-Powered Analysis** 
            - Intelligent remediation guidance
            - Risk-based prioritization
            - Automated fix recommendations
            
            **‚ö° Automated Remediation**
            - One-click security fixes
            - Safe dry-run mode
            - Change verification
            """)

    def display_results(self):
        resources = st.session_state.scan_results['resources']
        vulnerabilities = st.session_state.get('filtered_vulnerabilities', [])
        
        # Display metrics
        self.display_metrics(resources, vulnerabilities)
        
        # Tabs for different views
        tab1, tab2, tab3 = st.tabs([
            "üìã Vulnerabilities", 
            "üîß Resources", 
            "‚ö° Remediation"
        ])
        
        with tab1:
            self.display_vulnerabilities_tab(vulnerabilities)
        
        with tab2:
            self.display_resources_tab(resources)
        
        with tab3:
            self.display_remediation_tab(vulnerabilities)

    def display_metrics(self, resources, vulnerabilities):
        st.subheader("üìä Security Overview")
        
        col1, col2, col3, col4 = st.columns(4)
        
        total_resources = len(resources)
        total_vulns = len(vulnerabilities)
        high_vulns = len([v for v in vulnerabilities if v['severity'] == 'HIGH'])
        med_vulns = len([v for v in vulnerabilities if v['severity'] == 'MEDIUM'])
        
        with col1:
            st.metric("Total Resources", total_resources)
        with col2:
            st.metric("Vulnerabilities", total_vulns)
        with col3:
            st.metric("High Severity", high_vulns)
        with col4:
            st.metric("Medium Severity", med_vulns)

    def display_vulnerabilities_tab(self, vulnerabilities):
        st.header("üìã Detected Vulnerabilities")
        
        if not vulnerabilities:
            st.info("üéâ No vulnerabilities found!")
            return
        
        for idx, vuln in enumerate(vulnerabilities):
            severity_class = f"severity-{vuln['severity'].lower()}"
            
            with st.expander(f"{vuln['severity']} - {vuln['title']} - {vuln['resource_name']}"):
                col1, col2 = st.columns(2)
                
                with col1:
                    st.write(f"**Resource:** {vuln['service']} - {vuln['resource_name']}")
                    st.write(f"**Severity:** <span class='{severity_class}'>{vuln['severity']}</span>", unsafe_allow_html=True)
                    st.write(f"**Category:** {vuln.get('category', 'General')}")
                
                with col2:
                    st.write(f"**Description:** {vuln['description']}")
                    st.write(f"**Remediation:** {vuln.get('remediation', 'Review required')}")
                
                col1, col2 = st.columns(2)
                with col1:
                    if st.button(f"Select for Remediation", key=f"select_{idx}"):
                        if vuln not in st.session_state.selected_vulnerabilities:
                            st.session_state.selected_vulnerabilities.append(vuln)
                            st.success(f"Added {vuln['title']} to remediation!")

    def display_resources_tab(self, resources):
        st.header("üîß Scanned Resources")
        
        if not resources:
            st.info("No resources found.")
            return
        
        for resource in resources:
            with st.expander(f"{resource['service']} - {resource.get('name', resource['resource_id'])}"):
                st.write(f"**Resource ID:** {resource['resource_id']}")
                st.write(f"**Type:** {resource['resource_type']}")
                st.write(f"**Service:** {resource['service']}")
                
                if resource.get('vulnerabilities'):
                    st.write("**Vulnerabilities:**")
                    for vuln in resource['vulnerabilities']:
                        st.write(f"- {vuln['title']} ({vuln['severity']})")

    def display_remediation_tab(self, vulnerabilities):
        st.header("‚ö° Remediation Hub")
        
        selected_vulns = st.session_state.selected_vulnerabilities
        
        if not selected_vulns:
            st.info("Select vulnerabilities from the Vulnerabilities tab to begin remediation.")
            return
        
        st.subheader("Selected for Remediation")
        
        for idx, vuln in enumerate(selected_vulns):
            col1, col2 = st.columns([4, 1])
            with col1:
                st.write(f"**{vuln['title']}** - {vuln['resource_name']} ({vuln['severity']})")
            with col2:
                if st.button("Remove", key=f"remove_{idx}"):
                    st.session_state.selected_vulnerabilities.remove(vuln)
                    st.rerun()
        
        st.subheader("Remediation Actions")
        
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("Generate Plan", use_container_width=True):
                st.session_state.remediation_plan = self._generate_remediation_plan(selected_vulns)
                st.success("Remediation plan generated!")
        
        with col2:
            if st.button("Execute Remediation", use_container_width=True, type="primary"):
                self._execute_remediation(selected_vulns)
        
        if st.session_state.remediation_plan:
            st.subheader("Remediation Plan")
            st.json(st.session_state.remediation_plan)

    def _generate_remediation_plan(self, vulnerabilities):
        """Generate remediation plan"""
        return {
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': [v['id'] for v in vulnerabilities],
            'steps': [f"Remediate {v['title']} on {v['resource_name']}" for v in vulnerabilities]
        }

    def _execute_remediation(self, vulnerabilities):
        """Execute remediation"""
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        for i, vuln in enumerate(vulnerabilities):
            status_text.text(f"Remediating {vuln['title']}...")
            time.sleep(1)  # Simulate work
            
            result_id = f"{vuln['resource_id']}_{vuln['id']}"
            st.session_state.remediation_results[result_id] = {
                'status': 'success',
                'message': f'Remediated {vuln["title"]}',
                'timestamp': datetime.now().isoformat()
            }
            
            progress_bar.progress((i + 1) / len(vulnerabilities))
        
        status_text.text("Remediation completed!")
        st.balloons()

def main():
    app = AWSVulnerabilityApp()
    app.display_dashboard()

if __name__ == "__main__":
    main()