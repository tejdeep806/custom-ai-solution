import streamlit as st
import boto3
import json
from datetime import datetime
from typing import Dict, List, Any
import os
from dotenv import load_dotenv
import time

# Load environment variables at the start
load_dotenv()

# Set page config FIRST - this must be the first Streamlit command
st.set_page_config(
    page_title="AWS Vulnerability Remediation AI",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS - after page config
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #FF4B4B;
        text-align: center;
        margin-bottom: 2rem;
    }
    .severity-critical { background-color: #FF0000; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-high { background-color: #FF4B4B; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-medium { background-color: #FFA500; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-low { background-color: #008000; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    .severity-info { background-color: #0066CC; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
    
    .resource-card { 
        border-left: 5px solid #FF4B4B; 
        padding: 15px; 
        margin: 10px 0; 
        background-color: #f0f2f6;
        border-radius: 5px;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        margin: 5px;
        border: 1px solid #ddd;
    }
    .service-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
        margin: 10px;
    }
    .vulnerability-item {
        border-left: 4px solid;
        padding: 10px;
        margin: 5px 0;
        background-color: #f8f9fa;
        border-radius: 5px;
    }
    .success-box { background-color: #d4edda; border-left: 5px solid #28a745; padding: 15px; border-radius: 5px; }
    .warning-box { background-color: #fff3cd; border-left: 5px solid #ffc107; padding: 15px; border-radius: 5px; }
    .error-box { background-color: #f8d7da; border-left: 5px solid #dc3545; padding: 15px; border-radius: 5px; }
    .info-box { background-color: #d1ecf1; border-left: 5px solid #17a2b8; padding: 15px; border-radius: 5px; }
    
    .tab-content {
        padding: 20px;
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        margin: 10px 0;
    }
    
    .resource-details {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border-left: 4px solid #007bff;
    }
    
    .remediation-step {
        background-color: #f8f9fa;
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #28a745;
    }
    
    .security-tip {
        background-color: #e7f3ff;
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #17a2b8;
    }
    
    .secrets-status {
        background-color: #fff3cd;
        padding: 10px;
        border-radius: 5px;
        border-left: 4px solid #ffc107;
        margin: 10px 0;
    }
</style>
""", unsafe_allow_html=True)

class AWSSecretsManager:
    def __init__(self):
        self.secrets_client = None
        self.initialize_secrets_client()
    
    def initialize_secrets_client(self):
        """Initialize Secrets Manager client with fallback options"""
        try:
            # Try to initialize with environment variables first
            access_key = os.getenv('AWS_ACCESS_KEY_ID')
            secret_key = os.getenv('AWS_SECRET_ACCESS_KEY')
            region = os.getenv('AWS_REGION', 'us-east-1')
            
            if access_key and secret_key:
                self.secrets_client = boto3.client(
                    'secretsmanager',
                    aws_access_key_id=access_key,
                    aws_secret_access_key=secret_key,
                    region_name=region
                )
                st.success("‚úÖ Secrets Manager initialized with environment credentials")
            else:
                # Try with IAM role (for EC2/ECS/Lambda)
                self.secrets_client = boto3.client('secretsmanager', region_name=region)
                st.success("‚úÖ Secrets Manager initialized with IAM role")
                
        except Exception as e:
            st.error(f"‚ùå Failed to initialize Secrets Manager: {e}")
            self.secrets_client = None
    
    def get_secret(self, secret_arn):
        """Retrieve secret from AWS Secrets Manager"""
        if not self.secrets_client:
            st.error("Secrets Manager client not initialized")
            return None
        
        try:
            response = self.secrets_client.get_secret_value(SecretId=secret_arn)
            
            if 'SecretString' in response:
                secret_data = json.loads(response['SecretString'])
                st.success(f"‚úÖ Successfully retrieved credentials from Secrets Manager")
                return secret_data
            else:
                st.error("Secret found but no SecretString available")
                return None
                
        except Exception as e:
            st.error(f"‚ùå Failed to retrieve secret from {secret_arn}: {e}")
            return None
    
    def test_connection(self, secret_arn):
        """Test connection to Secrets Manager"""
        try:
            self.secrets_client.describe_secret(SecretId=secret_arn)
            return True
        except Exception as e:
            st.error(f"‚ùå Cannot access secret {secret_arn}: {e}")
            return False

class AWSVulnerabilityApp:
    def __init__(self):
        # Initialize Secrets Manager
        self.secrets_manager = AWSSecretsManager()
        
        # Initialize session state variables
        if 'scan_results' not in st.session_state:
            st.session_state.scan_results = None
        if 'selected_vulnerabilities' not in st.session_state:
            st.session_state.selected_vulnerabilities = []
        if 'remediation_results' not in st.session_state:
            st.session_state.remediation_results = {}
        if 'ai_analysis_cache' not in st.session_state:
            st.session_state.ai_analysis_cache = {}
        if 'remediation_plan' not in st.session_state:
            st.session_state.remediation_plan = None
        if 'selected_services' not in st.session_state:
            st.session_state.selected_services = ['EC2', 'EKS', 'Lambda']
        if 'scan_details' not in st.session_state:
            st.session_state.scan_details = {}
        if 'execution_mode' not in st.session_state:
            st.session_state.execution_mode = 'dry-run'
        if 'aws_credentials' not in st.session_state:
            st.session_state.aws_credentials = None
            
        # Try to load credentials from Secrets Manager
        self.load_credentials_from_secrets_manager()
        
        # Initialize AWS clients with retrieved credentials
        self.aws_clients = self._setup_aws_clients()
    
    def load_credentials_from_secrets_manager(self):
        """Load AWS credentials from Secrets Manager"""
        # Your Secrets Manager ARN
        SECRET_ARN = "arn:aws:secretsmanager:us-east-1:736496772981:secret:awsusercreds-IoJQmU"
        
        # Check if we already have credentials
        if st.session_state.aws_credentials is None:
            with st.spinner("üîê Loading credentials from AWS Secrets Manager..."):
                credentials = self.secrets_manager.get_secret(SECRET_ARN)
                if credentials:
                    st.session_state.aws_credentials = credentials
                    st.success("‚úÖ Credentials loaded successfully from Secrets Manager!")
                else:
                    st.warning("‚ö†Ô∏è Using demo mode - no credentials available")
    
    def _setup_aws_clients(self):
        """Setup AWS clients using credentials from Secrets Manager"""
        try:
            if not st.session_state.aws_credentials:
                st.warning("‚ö†Ô∏è No AWS credentials available. Using demo mode.")
                return None
            
            credentials = st.session_state.aws_credentials
            region = credentials.get('AWS_REGION', 'us-east-1')
            
            session = boto3.Session(
                aws_access_key_id=credentials.get('AWS_ACCESS_KEY_ID'),
                aws_secret_access_key=credentials.get('AWS_SECRET_ACCESS_KEY'),
                region_name=region
            )
            
            clients = {
                'ec2': session.client('ec2'),
                'eks': session.client('eks'), 
                'lambda': session.client('lambda'),
                'securityhub': session.client('securityhub'),
                'inspector2': session.client('inspector2'),
                'iam': session.client('iam'),
                'cloudtrail': session.client('cloudtrail'),
                's3': session.client('s3'),
                'rds': session.client('rds'),
                'secretsmanager': session.client('secretsmanager'),
            }
            
            # Try to setup Bedrock
            try:
                clients['bedrock-runtime'] = session.client('bedrock-runtime', region_name=region)
                st.success("‚úÖ AWS Bedrock configured successfully!")
            except Exception as e:
                st.info(f"‚ÑπÔ∏è Bedrock not available: {e}. Using simulated AI analysis.")
                clients['bedrock-runtime'] = None
                
            st.success(f"‚úÖ AWS clients configured for region: {region}")
            return clients
            
        except Exception as e:
            st.error(f"‚ùå AWS setup failed: {e}")
            return None

    def get_aws_regions(self):
        """Get available AWS regions"""
        try:
            if not self.aws_clients:
                return ['us-east-1', 'us-west-2', 'eu-west-1']
                
            ec2 = self.aws_clients['ec2']
            regions = [region['RegionName'] for region in ec2.describe_regions()['Regions']]
            return regions
        except Exception as e:
            st.error(f"Failed to get regions: {e}")
            return ['us-east-1', 'us-west-2', 'eu-west-1']

    def display_credentials_status(self):
        """Display current credentials status"""
        if st.session_state.aws_credentials:
            credentials = st.session_state.aws_credentials
            st.markdown("""
            <div class="secrets-status">
                <strong>üîê Credentials Source:</strong> AWS Secrets Manager<br>
                <strong>üë§ Access Key ID:</strong> {}...<br>
                <strong>üåç Region:</strong> {}<br>
                <strong>üîÑ Last Updated:</strong> {}
            </div>
            """.format(
                credentials.get('AWS_ACCESS_KEY_ID', '')[:10],
                credentials.get('AWS_REGION', 'us-east-1'),
                datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            ), unsafe_allow_html=True)
        else:
            st.error("""
            <div class="secrets-status">
                <strong>‚ùå No AWS Credentials Available</strong><br>
                Using demo mode with sample data. Real AWS scanning disabled.
            </div>
            """, unsafe_allow_html=True)

    def refresh_credentials(self):
        """Refresh credentials from Secrets Manager"""
        st.session_state.aws_credentials = None
        self.load_credentials_from_secrets_manager()
        # Reinitialize clients with new credentials
        self.aws_clients = self._setup_aws_clients()
        st.rerun()

    # ... (keep all your existing methods from the previous version: run_comprehensive_scan, _scan_ec2_detailed, etc.)
    # The scanning and analysis methods remain exactly the same

    def run_comprehensive_scan(self, selected_services):
        """Run comprehensive AWS security scan with detailed resource discovery"""
        with st.spinner('üîç Performing comprehensive AWS security scan...'):
            try:
                if not self.aws_clients:
                    st.warning("üö® No AWS credentials available. Using demo data.")
                    self.run_basic_scan()
                    return
                
                scan_details = {}
                total_resources = 0
                
                # Progress tracking
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                steps = len(selected_services)
                current_step = 0
                
                if 'EC2' in selected_services:
                    current_step += 1
                    status_text.text(f"üñ•Ô∏è Scanning EC2 Instances... ({current_step}/{steps})")
                    ec2_resources = self._scan_ec2_detailed()
                    scan_details['EC2'] = ec2_resources
                    total_resources += len(ec2_resources)
                    progress_bar.progress(current_step/steps)
                
                if 'EKS' in selected_services:
                    current_step += 1
                    status_text.text(f"‚ò∏Ô∏è Scanning EKS Clusters... ({current_step}/{steps})")
                    eks_resources = self._scan_eks_detailed()
                    scan_details['EKS'] = eks_resources
                    total_resources += len(eks_resources)
                    progress_bar.progress(current_step/steps)
                
                if 'Lambda' in selected_services:
                    current_step += 1
                    status_text.text(f"Œª Scanning Lambda Functions... ({current_step}/{steps})")
                    lambda_resources = self._scan_lambda_detailed()
                    scan_details['Lambda'] = lambda_resources
                    total_resources += len(lambda_resources)
                    progress_bar.progress(current_step/steps)
                
                if 'IAM' in selected_services:
                    current_step += 1
                    status_text.text(f"üë§ Scanning IAM Resources... ({current_step}/{steps})")
                    iam_findings = self._scan_iam_detailed()
                    scan_details['IAM'] = iam_findings
                    total_resources += len(iam_findings)
                    progress_bar.progress(current_step/steps)
                
                if 'S3' in selected_services:
                    current_step += 1
                    status_text.text(f"ü™£ Scanning S3 Buckets... ({current_step}/{steps})")
                    s3_findings = self._scan_s3_detailed()
                    scan_details['S3'] = s3_findings
                    total_resources += len(s3_findings)
                    progress_bar.progress(current_step/steps)
                
                # Combine all resources and vulnerabilities
                all_resources = []
                for service_resources in scan_details.values():
                    all_resources.extend(service_resources)
                
                vulnerabilities = self._extract_vulnerabilities(all_resources)
                
                st.session_state.scan_results = {
                    'resources': all_resources,
                    'vulnerabilities': vulnerabilities,
                    'scan_time': datetime.now().isoformat(),
                    'is_demo': not self.aws_clients,
                    'scan_details': scan_details,
                    'total_resources': total_resources
                }
                
                progress_bar.progress(1.0)
                status_text.text("‚úÖ Scan completed successfully!")
                
                st.success(f"üéØ Scan Complete: Found {total_resources} resources and {len(vulnerabilities)} vulnerabilities")
                
            except Exception as e:
                st.error(f"‚ùå Comprehensive scan failed: {e}")
                # Fallback to basic scan
                self.run_basic_scan()

    def _scan_ec2_detailed(self):
        """Detailed EC2 instance scanning"""
        resources = []
        try:
            ec2 = self.aws_clients['ec2']
            
            # Get all instances with detailed information
            paginator = ec2.get_paginator('describe_instances')
            for page in paginator.paginate():
                for reservation in page['Reservations']:
                    for instance in reservation['Instances']:
                        # Get detailed instance information
                        instance_details = {
                            'resource_id': instance['InstanceId'],
                            'resource_type': 'EC2',
                            'service': 'EC2',
                            'name': self._get_resource_name(instance.get('Tags', [])),
                            'state': instance['State']['Name'],
                            'instance_type': instance.get('InstanceType', 'N/A'),
                            'launch_time': instance['LaunchTime'].strftime('%Y-%m-%d %H:%M:%S'),
                            'vpc_id': instance.get('VpcId', 'N/A'),
                            'subnet_id': instance.get('SubnetId', 'N/A'),
                            'public_ip': instance.get('PublicIpAddress', 'Not Assigned'),
                            'private_ip': instance.get('PrivateIpAddress', 'N/A'),
                            'security_groups': [sg['GroupId'] for sg in instance.get('SecurityGroups', [])],
                            'key_name': instance.get('KeyName', 'N/A'),
                            'image_id': instance.get('ImageId', 'N/A'),
                            'availability_zone': instance.get('Placement', {}).get('AvailabilityZone', 'N/A'),
                            'vulnerabilities': self._check_ec2_vulnerabilities_detailed(instance)
                        }
                        resources.append(instance_details)
            
            st.info(f"üîç Found {len(resources)} EC2 instances")
            
        except Exception as e:
            st.error(f"EC2 scan error: {e}")
        
        return resources

    def _scan_eks_detailed(self):
        """Detailed EKS cluster scanning"""
        resources = []
        try:
            eks = self.aws_clients['eks']
            
            # List all EKS clusters
            clusters = eks.list_clusters()
            
            for cluster_name in clusters.get('clusters', []):
                # Get detailed cluster information
                cluster_info = eks.describe_cluster(name=cluster_name)
                cluster_data = cluster_info['cluster']
                
                cluster_details = {
                    'resource_id': cluster_data['name'],
                    'resource_type': 'EKS',
                    'service': 'EKS',
                    'name': cluster_data['name'],
                    'status': cluster_data['status'],
                    'version': cluster_data['version'],
                    'arn': cluster_data['arn'],
                    'endpoint': cluster_data.get('endpoint', 'N/A'),
                    'created_at': cluster_data.get('createdAt', 'N/A').strftime('%Y-%m-%d %H:%M:%S'),
                    'vpc_config': cluster_data.get('resourcesVpcConfig', {}),
                    'logging': cluster_data.get('logging', {}),
                    'vulnerabilities': self._check_eks_vulnerabilities_detailed(cluster_data)
                }
                resources.append(cluster_details)
            
            st.info(f"üîç Found {len(resources)} EKS clusters")
            
        except Exception as e:
            st.error(f"EKS scan error: {e}")
        
        return resources

    def _scan_lambda_detailed(self):
        """Detailed Lambda function scanning"""
        resources = []
        try:
            lambda_client = self.aws_clients['lambda']
            
            # Get all Lambda functions with pagination
            paginator = lambda_client.get_paginator('list_functions')
            for page in paginator.paginate():
                for function in page['Functions']:
                    function_details = {
                        'resource_id': function['FunctionName'],
                        'resource_type': 'Lambda',
                        'service': 'Lambda',
                        'name': function['FunctionName'],
                        'runtime': function.get('Runtime', 'N/A'),
                        'last_modified': function['LastModified'],
                        'memory_size': function.get('MemorySize', 'N/A'),
                        'timeout': function.get('Timeout', 'N/A'),
                        'arn': function['FunctionArn'],
                        'role': function.get('Role', 'N/A'),
                        'handler': function.get('Handler', 'N/A'),
                        'code_size': function.get('CodeSize', 0),
                        'environment_vars': list(function.get('Environment', {}).get('Variables', {}).keys()) if function.get('Environment') else [],
                        'vpc_config': function.get('VpcConfig', {}),
                        'vulnerabilities': self._check_lambda_vulnerabilities_detailed(function)
                    }
                    resources.append(function_details)
            
            st.info(f"üîç Found {len(resources)} Lambda functions")
            
        except Exception as e:
            st.error(f"Lambda scan error: {e}")
        
        return resources

    def _scan_iam_detailed(self):
        """Basic IAM security scanning"""
        findings = []
        try:
            iam = self.aws_clients['iam']
            
            # Check for root user access keys
            try:
                summary = iam.get_account_summary()
                if summary['SummaryMap']['AccountAccessKeysPresent'] == 1:
                    findings.append({
                        'resource_id': 'ROOT_USER',
                        'resource_type': 'IAM',
                        'service': 'IAM',
                        'name': 'Root User',
                        'vulnerabilities': [{
                            'id': 'IAM-ROOT-KEYS',
                            'title': 'Root Access Keys Exist',
                            'severity': 'CRITICAL',
                            'description': 'Root user access keys are present. This is a security risk.',
                            'remediation': 'Remove root access keys and use IAM users/roles',
                            'category': 'IAM Security'
                        }]
                    })
            except:
                pass
            
            st.info(f"üîç Found {len(findings)} IAM security findings")
            
        except Exception as e:
            st.error(f"IAM scan error: {e}")
        
        return findings

    def _scan_s3_detailed(self):
        """Basic S3 security scanning"""
        findings = []
        try:
            s3 = self.aws_clients['s3']
            
            # List buckets and check for public access
            buckets = s3.list_buckets()
            for bucket in buckets.get('Buckets', []):
                bucket_name = bucket['Name']
                
                try:
                    # Check bucket ACL
                    acl = s3.get_bucket_acl(Bucket=bucket_name)
                    for grant in acl.get('Grants', []):
                        grantee = grant.get('Grantee', {})
                        if grantee.get('Type') == 'Group' and 'AllUsers' in grantee.get('URI', ''):
                            findings.append({
                                'resource_id': bucket_name,
                                'resource_type': 'S3',
                                'service': 'S3',
                                'name': bucket_name,
                                'vulnerabilities': [{
                                    'id': 'S3-PUBLIC-ACCESS',
                                    'title': 'S3 Bucket Public Access',
                                    'severity': 'HIGH',
                                    'description': f'S3 bucket {bucket_name} has public access enabled',
                                    'remediation': 'Restrict bucket ACL and enable block public access',
                                    'category': 'Data Protection'
                                }]
                            })
                            break
                except:
                    pass
            
            st.info(f"üîç Found {len(findings)} S3 security findings")
            
        except Exception as e:
            st.error(f"S3 scan error: {e}")
        
        return findings

    # ... (keep all your existing vulnerability check methods)
    def _check_ec2_vulnerabilities_detailed(self, instance):
        """Detailed EC2 vulnerability checks"""
        vulnerabilities = []
        
        # Public IP check
        if instance.get('PublicIpAddress'):
            vulnerabilities.append({
                'id': 'EC2-PUBLIC-IP',
                'title': 'EC2 Instance with Public IP',
                'severity': 'HIGH',
                'description': f"Instance {instance['InstanceId']} has public IP {instance['PublicIpAddress']} and is directly accessible from internet",
                'remediation': 'Move instance to private subnet or remove public IP',
                'category': 'Network Security',
                'resource_specific': {
                    'public_ip': instance['PublicIpAddress'],
                    'subnet_type': 'Public' if instance.get('PublicIpAddress') else 'Private'
                }
            })
        
        # IMDS configuration
        metadata_options = instance.get('MetadataOptions', {})
        if metadata_options.get('HttpTokens') != 'required':
            vulnerabilities.append({
                'id': 'EC2-IMDS-V1',
                'title': 'IMDSv1 Enabled',
                'severity': 'MEDIUM',
                'description': 'Instance Metadata Service v1 is enabled (less secure than v2)',
                'remediation': 'Enforce IMDSv2 only',
                'category': 'Instance Security'
            })
        
        # Security group checks
        for sg in instance.get('SecurityGroups', []):
            sg_vulns = self._check_security_group_detailed(sg['GroupId'])
            vulnerabilities.extend(sg_vulns)
        
        return vulnerabilities

    def _check_security_group_detailed(self, sg_id):
        """Detailed security group vulnerability checks"""
        vulnerabilities = []
        try:
            ec2 = self.aws_clients['ec2']
            
            response = ec2.describe_security_group_rules(
                Filters=[{'Name': 'group-id', 'Values': [sg_id]}]
            )
            
            for rule in response['SecurityGroupRules']:
                if rule.get('IsEgress', False):
                    continue
                
                # Check for open CIDR
                if rule.get('CidrIpv4') == '0.0.0.0/0':
                    port_info = ""
                    if rule.get('FromPort') == rule.get('ToPort'):
                        port_info = f"port {rule.get('FromPort')}"
                    else:
                        port_info = f"ports {rule.get('FromPort')}-{rule.get('ToPort')}"
                    
                    severity = 'HIGH' if rule.get('FromPort') in [22, 3389, 1433, 3306] else 'MEDIUM'
                    
                    vulnerabilities.append({
                        'id': f'SG-OPEN-{rule.get("FromPort", "ANY")}',
                        'title': f'{rule["IpProtocol"].upper()} {port_info} Open To Internet',
                        'severity': severity,
                        'description': f'Security group {sg_id} allows {rule["IpProtocol"]} {port_info} from anywhere (0.0.0.0/0)',
                        'remediation': 'Restrict source IP range to specific networks',
                        'category': 'Network Security',
                        'resource_specific': {
                            'protocol': rule['IpProtocol'],
                            'port_range': f"{rule.get('FromPort', 'Any')}-{rule.get('ToPort', 'Any')}",
                            'source': '0.0.0.0/0'
                        }
                    })
        
        except Exception as e:
            st.error(f"Security group check error for {sg_id}: {e}")
        
        return vulnerabilities

    def _check_eks_vulnerabilities_detailed(self, cluster):
        """Detailed EKS vulnerability checks"""
        vulnerabilities = []
        
        # Check logging
        logging = cluster.get('logging', {}).get('clusterLogging', [{}])[0]
        if not logging.get('enabled', False):
            vulnerabilities.append({
                'id': 'EKS-LOGGING-DISABLED',
                'title': 'Control Plane Logging Disabled',
                'severity': 'MEDIUM',
                'description': 'EKS control plane logging is not enabled for audit purposes',
                'remediation': 'Enable control plane logging for all log types',
                'category': 'Logging & Monitoring'
            })
        
        return vulnerabilities

    def _check_lambda_vulnerabilities_detailed(self, function):
        """Detailed Lambda vulnerability checks"""
        vulnerabilities = []
        
        # Environment variables check
        env_vars = function.get('Environment', {}).get('Variables', {})
        if env_vars:
            # Check for potential secrets in environment variable names
            secret_keywords = ['password', 'secret', 'key', 'token', 'credential']
            has_potential_secrets = any(
                any(keyword in key.lower() for keyword in secret_keywords)
                for key in env_vars.keys()
            )
            
            if has_potential_secrets:
                vulnerabilities.append({
                    'id': 'LAMBDA-ENV-SECRETS',
                    'title': 'Potential Secrets in Environment Variables',
                    'severity': 'HIGH',
                    'description': 'Environment variables may contain sensitive data like passwords or API keys',
                    'remediation': 'Use AWS Secrets Manager for sensitive data instead of environment variables',
                    'category': 'Data Protection'
                })
        
        return vulnerabilities

    def _get_resource_name(self, tags):
        """Extract name from resource tags"""
        for tag in tags:
            if tag['Key'] == 'Name':
                return tag['Value']
        return 'Unnamed'

    def _extract_vulnerabilities(self, resources):
        """Extract vulnerabilities from resources"""
        vulnerabilities = []
        for resource in resources:
            for vuln in resource.get('vulnerabilities', []):
                vuln_data = vuln.copy()
                vuln_data['resource_id'] = resource['resource_id']
                vuln_data['resource_type'] = resource['resource_type']
                vuln_data['resource_name'] = resource.get('name', resource['resource_id'])
                vuln_data['service'] = resource.get('service', 'Unknown')
                vulnerabilities.append(vuln_data)
        return vulnerabilities

    def run_basic_scan(self):
        """Basic scan fallback"""
        resources = self._get_demo_resources()
        vulnerabilities = self._extract_vulnerabilities(resources)
        
        st.session_state.scan_results = {
            'resources': resources,
            'vulnerabilities': vulnerabilities,
            'scan_time': datetime.now().isoformat(),
            'is_demo': True
        }

    def _get_demo_resources(self):
        """Get demo resources for testing"""
        return [
            {
                'resource_id': 'i-1234567890abcdef0',
                'resource_type': 'EC2',
                'service': 'EC2',
                'name': 'web-server-1',
                'state': 'running',
                'instance_type': 't3.medium',
                'public_ip': '54.210.100.50',
                'vulnerabilities': [
                    {
                        'id': 'EC2-PUBLIC-IP',
                        'title': 'EC2 Instance with Public IP',
                        'severity': 'HIGH',
                        'description': 'Instance has a public IP address and is directly accessible from internet',
                        'remediation': 'Move instance to private subnet or remove public IP',
                        'category': 'Network Security'
                    }
                ]
            }
        ]

    def display_dashboard(self):
        st.markdown('<h1 class="main-header">üõ°Ô∏è AWS Vulnerability Remediation AI</h1>', unsafe_allow_html=True)
        
        # Display credentials status
        self.display_credentials_status()
        
        # Sidebar with enhanced controls
        self.display_enhanced_sidebar()
        
        # Main content
        if st.session_state.scan_results is None:
            self.display_enhanced_welcome()
        else:
            self.display_enhanced_results()

    def display_enhanced_sidebar(self):
        with st.sidebar:
            st.header("üéØ Scan Controls")
            
            # Credentials management
            st.subheader("üîê Credentials Management")
            if st.button("üîÑ Refresh Credentials", use_container_width=True):
                self.refresh_credentials()
            
            # Service selection
            st.subheader("üîß Select Services to Scan")
            services = ['EC2', 'EKS', 'Lambda', 'IAM', 'S3']
            selected_services = st.multiselect(
                "AWS Services:",
                services,
                default=st.session_state.selected_services,
                help="Select which AWS services to scan for vulnerabilities"
            )
            
            # Scan options
            st.subheader("‚öôÔ∏è Scan Options")
            deep_scan = st.checkbox("Deep Security Scan", False, help="Perform comprehensive security checks")
            
            col1, col2 = st.columns(2)
            with col1:
                if st.button("üöÄ Run Comprehensive Scan", use_container_width=True, type="primary"):
                    st.session_state.selected_services = selected_services
                    self.run_comprehensive_scan(selected_services)
                    st.rerun()
            
            with col2:
                if st.button("üîÑ Quick Rescan", use_container_width=True):
                    self.run_comprehensive_scan(selected_services)
                    st.rerun()
            
            # Execution mode
            st.subheader("üîí Execution Mode")
            execution_mode = st.radio(
                "Remediation Mode:",
                ["Dry Run (Safe)", "Execute (Live)"],
                index=0,
                help="Dry Run shows what would be changed without making actual changes"
            )
            st.session_state.execution_mode = 'dry-run' if execution_mode == "Dry Run (Safe)" else 'execute'
            
            if st.session_state.scan_results:
                st.header("üîç Filters")
                vulnerabilities = st.session_state.scan_results['vulnerabilities']
                
                # Enhanced filters
                col1, col2 = st.columns(2)
                with col1:
                    # Resource type filter
                    resource_types = list(set([v['resource_type'] for v in vulnerabilities]))
                    selected_types = st.multiselect(
                        "Resource Types",
                        resource_types,
                        default=resource_types
                    )
                    
                    # Service filter
                    services = list(set([v.get('service', 'Unknown') for v in vulnerabilities]))
                    selected_services_filter = st.multiselect(
                        "Services",
                        services,
                        default=services
                    )
                
                with col2:
                    # Severity filter
                    severities = list(set([v['severity'] for v in vulnerabilities]))
                    selected_severities = st.multiselect(
                        "Severity Levels",
                        severities,
                        default=severities
                    )
                    
                    # Category filter
                    categories = list(set([v.get('category', 'General') for v in vulnerabilities]))
                    selected_categories = st.multiselect(
                        "Categories",
                        categories,
                        default=categories
                    )
                
                # Apply filters
                filtered_vulns = [
                    v for v in vulnerabilities 
                    if v['resource_type'] in selected_types 
                    and v['severity'] in selected_severities
                    and v.get('category', 'General') in selected_categories
                    and v.get('service', 'Unknown') in selected_services_filter
                ]
                
                st.session_state.filtered_vulnerabilities = filtered_vulns
                
                # Demo mode indicator
                if st.session_state.scan_results.get('is_demo'):
                    st.warning("üî∏ Demo Mode - Using sample data")
                else:
                    st.success("‚úÖ Live AWS Environment")

    def display_enhanced_welcome(self):
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.markdown("""
            <div style='text-align: center;'>
            <h2>üöÄ Welcome to AWS Vulnerability Remediation AI</h2>
            <p>Enterprise-grade cloud security with AI-powered automation</p>
            </div>
            """, unsafe_allow_html=True)
            
            # Service cards
            st.subheader("üõ°Ô∏è Protected Services")
            services_cols = st.columns(4)
            services = [
                ("üñ•Ô∏è", "EC2", "Instances, Security Groups"),
                ("‚ò∏Ô∏è", "EKS", "Clusters, Control Plane"),
                ("Œª", "Lambda", "Functions, Permissions"),
                ("ü™£", "S3", "Buckets, Access Control")
            ]
            
            for col, (icon, name, desc) in zip(services_cols, services):
                with col:
                    st.markdown(f"""
                    <div class="service-card">
                        <h3>{icon}</h3>
                        <h4>{name}</h4>
                        <small>{desc}</small>
                    </div>
                    """, unsafe_allow_html=True)
            
            # Quick actions
            st.subheader("‚ö° Quick Actions")
            if st.button("üìä Run Security Assessment", use_container_width=True):
                self.run_comprehensive_scan(['EC2', 'EKS', 'Lambda'])
                st.rerun()
        
        with col2:
            st.info("""
            ## ‚ú® Enhanced Features
            
            **üîê Secure Credentials Management**
            - AWS Secrets Manager integration
            - Automatic credential refresh
            - No local credential storage
            
            **üîç Comprehensive Scanning**
            - Real-time AWS resource discovery
            - Detailed vulnerability assessment
            - Multi-service security checks
            
            **ü§ñ AI-Powered Analysis** 
            - AWS Bedrock integration
            - Intelligent remediation plans
            - Risk-based prioritization
            
            **‚ö° Automated Remediation**
            - One-click security fixes
            - Safe execution modes
            - Change verification
            """)
            
            # Configuration status
            st.subheader("üîß Configuration Status")
            if self.aws_clients:
                st.success("‚úÖ AWS Clients: Configured")
                if self.aws_clients.get('bedrock-runtime'):
                    st.success("‚úÖ AWS Bedrock: Available")
                else:
                    st.warning("‚ö†Ô∏è AWS Bedrock: Not available in this region")
            else:
                st.error("‚ùå AWS Clients: Not configured")

    # ... (keep all your existing display methods: display_enhanced_results, display_enhanced_metrics, etc.)
    # These methods remain exactly the same as in the previous version

    def display_enhanced_results(self):
        resources = st.session_state.scan_results['resources']
        vulnerabilities = st.session_state.get('filtered_vulnerabilities', [])
        
        # Enhanced metrics dashboard
        self.display_enhanced_metrics(resources, vulnerabilities)
        
        # Enhanced tabs with more options
        tab1, tab2, tab3, tab4, tab5 = st.tabs([
            "üìã Vulnerability Dashboard", 
            "üîß Resource Explorer", 
            "ü§ñ AI Analysis Center", 
            "‚ö° Remediation Hub",
            "üìä Security Insights"
        ])
        
        with tab1:
            self.display_enhanced_vulnerabilities_tab(vulnerabilities)
        
        with tab2:
            self.display_enhanced_resources_tab(resources)
        
        with tab3:
            self.display_enhanced_analysis_tab(vulnerabilities)
        
        with tab4:
            self.display_enhanced_remediation_tab(vulnerabilities)
        
        with tab5:
            self.display_security_insights_tab(resources, vulnerabilities)

    def display_enhanced_metrics(self, resources, vulnerabilities):
        # ... (same as previous version)
        pass

    def display_enhanced_vulnerabilities_tab(self, vulnerabilities):
        # ... (same as previous version)
        pass

    def display_enhanced_resources_tab(self, resources):
        # ... (same as previous version)
        pass

    def display_enhanced_analysis_tab(self, vulnerabilities):
        # ... (same as previous version)
        pass

    def display_enhanced_remediation_tab(self, vulnerabilities):
        # ... (same as previous version)
        pass

    def display_security_insights_tab(self, resources, vulnerabilities):
        # ... (same as previous version)
        pass

    # ... (keep all your existing helper methods)

def main():
    app = AWSVulnerabilityApp()
    app.display_dashboard()

if __name__ == "__main__":
    main()